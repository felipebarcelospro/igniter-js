import { getSchema, Model, Property } from "@mrleebo/prisma-ast";
import * as fs from "fs/promises";
import * as path from "path";
import * as p from "@clack/prompts";
import { SchemaProvider, SchemaPromptContext, SchemaProviderSelection, SchemaGenerationContext } from "@/core/registry/schema-providers/base-schema-provider";
import { Casing } from "@/utils/casing";
import { FeatureWorkspace } from "../feature";

interface PrismaField {
  name: string;
  type: string;
  isRelation: boolean;
  isId: boolean;
  isOptional: boolean;
  hasDefault: boolean;
  isAutoGenerated: boolean;
}

export class PrismaSchemaProvider extends SchemaProvider {
  public readonly id = "prisma";
  public readonly name = "Prisma";
  public readonly defaultSchemaPath = path.join(process.cwd(), "prisma", "schema.prisma");

  public override async promptForSelection(
    context: SchemaPromptContext,
  ): Promise<SchemaProviderSelection | null> {
    const schemaPath = this.resolveSchemaPath(context.schemaPath);

    await this.validateSchemaPath(schemaPath);

    const models = await this.listModels(schemaPath);
    if (models.length === 0) {
      return null;
    }

    const choice = await p.select({
      message: "Which Prisma model would you like to scaffold?",
      options: models.map((model) => ({ value: model, label: model })),
      initialValue: models[0],
    });

    if (p.isCancel(choice)) {
      context.cancel("Feature generation cancelled.");
    }

    return {
      providerId: this.id,
      modelName: String(choice),
      schemaPath,
    };
  }

  public async validateSchemaPath(schemaPath: string): Promise<void> {
    try {
      const stat = await fs.stat(schemaPath);
      if (!stat.isFile()) {
        throw new Error();
      }
    } catch {
      throw new Error(`Prisma schema not found at '${schemaPath}'.`);
    }
  }

  public async listModels(schemaPath: string): Promise<string[]> {
    const content = await fs.readFile(schemaPath, "utf-8");
    const ast = getSchema(content);

    return ast.list
      .filter((node): node is Model => node.type === "model")
      .map((model) => model.name)
      .sort();
  }

  public async generateFeature(
    selection: SchemaProviderSelection,
    context: SchemaGenerationContext,
  ): Promise<void> {
    await this.validateSelection(selection);

    const schemaContent = await fs.readFile(selection.schemaPath, "utf-8");
    const ast = getSchema(schemaContent);
    const model = ast.list.find(
      (node): node is Model => node.type === "model" && node.name === selection.modelName,
    );

    if (!model) {
      throw new Error(`Model '${selection.modelName}' not found in Prisma schema.`);
    }

    const modelFields = this.extractFields(model);
    const target = this.buildNaming(selection.modelName, context.featureName);

    await this.ensurePathsAreFree(context.featureDir, context.featureName);

    const interfacesTemplate = context.templateEngine.resolvePath(
      "generate",
      "feature",
      "schema.interfaces.hbs",
    );
    const procedureTemplate = context.templateEngine.resolvePath(
      "generate",
      "feature",
      "schema.procedure.hbs",
    );
    const controllerTemplate = context.templateEngine.resolvePath(
      "generate",
      "feature",
      "schema.controller.hbs",
    );

    await context.templateEngine.renderToFile(
      interfacesTemplate,
      {
        modelName: target.modelNamePascal,
        fields: modelFields
          .filter((field) => !field.isRelation)
          .map((field) => ({
            name: field.name,
            zodType: this.getZodType(field.type, field.isOptional),
          })),
        createOmitFields: modelFields
          .filter((field) => field.isId || field.isAutoGenerated || field.hasDefault)
          .map((field) => field.name),
      },
      path.join(context.featureDir, `${context.featureName}.interfaces.ts`),
    );

    await context.templateEngine.renderToFile(
      procedureTemplate,
      {
        modelName: target.modelNamePascal,
        procedureExport: target.procedureExport,
        procedureDisplayName: `${target.modelNamePascal} Procedure`,
        prismaDelegate: target.prismaDelegate,
        featureName: context.featureName,
        idType: this.mapIdType(modelFields),
      },
      path.join(context.featureDir, "procedures", `${context.featureName}.procedure.ts`),
    );

    await context.templateEngine.renderToFile(
      controllerTemplate,
      {
        controllerExport: target.controllerExport,
        controllerDisplayName: `${target.modelNamePascal} Controller`,
        modelName: target.modelNamePascal,
        modelNamePlural: target.modelNamePlural,
        resourcePath: target.resourcePath,
        idZodType: this.getIdZodType(modelFields),
        featureName: context.featureName,
        procedureExport: target.procedureExport,
      },
      path.join(context.featureDir, "controllers", `${context.featureName}.controller.ts`),
    );
  }

  private extractFields(model: Model): PrismaField[] {
    return model.properties
      .filter((property): property is Property => property.type === "field")
      .map((property) => {
        const fieldType = property.fieldType as string;
        return {
          name: property.name,
          type: this.mapPrismaType(fieldType),
          isRelation: this.isRelation(fieldType),
          isId: this.hasAttribute(property, "id"),
          isOptional: Boolean((property as any).optional),
          hasDefault: this.hasAttribute(property, "default"),
          isAutoGenerated: this.isAutoGenerated(property),
        };
      });
  }

  private buildNaming(modelName: string, featureName: string) {
    const modelNamePascal = Casing.toPascalCase(modelName);
    return {
      modelNamePascal,
      modelNamePlural: Casing.pluralize(modelNamePascal),
      controllerExport: `${modelNamePascal}Controller`,
      procedureExport: `${modelNamePascal}Procedure`,
      resourcePath: Casing.pluralize(Casing.toCamelCase(modelName)),
      prismaDelegate: Casing.toCamelCase(modelName),
    };
  }

  private async ensurePathsAreFree(
    featureDir: string,
    featureSlug: string,
  ): Promise<void> {
    const filesToCheck = [
      path.join(featureDir, "controllers", `${featureSlug}.controller.ts`),
      path.join(featureDir, "procedures", `${featureSlug}.procedure.ts`),
      path.join(featureDir, `${featureSlug}.interfaces.ts`),
    ];

    for (const file of filesToCheck) {
      if (await FeatureWorkspace.fileExists(file)) {
        throw new Error(`File '${path.relative(process.cwd(), file)}' already exists.`);
      }
    }
  }

  private mapPrismaType(type: string): string {
    const cleanType = type.replace(/\?$/, "");
    switch (cleanType) {
      case "String":
      case "Json":
      case "Bytes":
      case "Unsupported":
        return "string";
      case "BigInt":
        return "bigint";
      case "Int":
      case "Float":
      case "Decimal":
        return "number";
      case "Boolean":
        return "boolean";
      case "DateTime":
        return "Date";
      default:
        return "string";
    }
  }

  private getZodType(type: string, optional: boolean): string {
    let base: string;
    switch (type) {
      case "string":
        base = "z.string()";
        break;
      case "number":
        base = "z.number()";
        break;
      case "boolean":
        base = "z.boolean()";
        break;
      case "Date":
        base = "z.date()";
        break;
      case "bigint":
        base = "z.bigint()";
        break;
      default:
        base = "z.any()";
    }
    return optional ? `${base}.nullable()` : base;
  }

  private getIdZodType(fields: PrismaField[]): string {
    const idField = fields.find((field) => field.isId);
    if (!idField) {
      return "z.string()";
    }
    if (idField.type === "number") {
      return "z.coerce.number()";
    }
    if (idField.type === "bigint") {
      return "z.coerce.bigint()";
    }
    return "z.string()";
  }

  private mapIdType(fields: PrismaField[]): string {
    const idField = fields.find((field) => field.isId);
    if (!idField) {
      return "string";
    }
    return idField.type;
  }

  private hasAttribute(property: Property, attributeName: string): boolean {
    return Array.isArray(property.attributes)
      ? property.attributes.some((attribute) => attribute.name === attributeName)
      : false;
  }

  private isAutoGenerated(property: Property): boolean {
    if (!Array.isArray(property.attributes)) {
      return false;
    }
    const defaultAttribute = property.attributes.find(
      (attribute) => attribute.name === "default",
    );
    if (!defaultAttribute || !Array.isArray(defaultAttribute.args)) {
      return false;
    }
    const defaultValue = defaultAttribute.args[0]?.value;
    return (
      typeof defaultValue === "string" &&
      ["autoincrement()", "now()", "cuid()", "uuid()"].includes(defaultValue)
    );
  }

  private isRelation(type: string): boolean {
    return /^[A-Z]/.test(type) && !["String", "Int", "Boolean", "DateTime", "Float", "Decimal", "BigInt", "Json", "Bytes"].includes(type);
  }
}
