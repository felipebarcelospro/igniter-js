import { getSchema, Model, Property } from "@mrleebo/prisma-ast";
import { readFile } from "fs/promises";
import * as path from "path";
import { createLogger } from "@/core/logger";
import type { ModelSchema, SchemaProvider, SchemaProviderField } from "./base";

const logger = createLogger("generate:prisma-provider");

function mapPrismaTypeToTsType(prismaType: string): string {
  const cleanType = prismaType.replace("?", "");
  switch (cleanType) {
    case "String":
    case "Json":
    case "Bytes":
    case "Unsupported":
      return "string";
    case "BigInt":
      return "bigint";
    case "Int":
    case "Float":
    case "Decimal":
      return "number";
    case "Boolean":
      return "boolean";
    case "DateTime":
      return "Date";
    default:
      return "string";
  }
}

function hasAttribute(prop: Property, attributeName: string): boolean {
  if (prop.type !== "field" || !Array.isArray(prop.attributes)) {
    return false;
  }

  return prop.attributes.some((attr) => attr.name === attributeName);
}

export class PrismaProvider implements SchemaProvider {
  private readonly schemaPath: string;

  constructor(customPath?: string) {
    this.schemaPath =
      customPath || path.join(process.cwd(), "prisma", "schema.prisma");
  }

  public async getModel(modelName: string): Promise<ModelSchema | null> {
    try {
      const schemaContent = await readFile(this.schemaPath, "utf-8");
      const ast = getSchema(schemaContent);

      const model = ast.list.find(
        (node): node is Model =>
          node.type === "model" && node.name === modelName,
      );

      if (!model) {
        logger.warn(`Model '${modelName}' not found in schema.`);
        return null;
      }

      const fields: SchemaProviderField[] = model.properties
        .filter((prop): prop is Property => prop.type === "field")
        .map((prop) => {
          if (
            prop.type !== "field" ||
            !("fieldType" in prop) ||
            !("name" in prop)
          ) {
            throw new Error(
              `Invalid field property structure for property ${String(prop)}`,
            );
          }

          const fieldType = prop.fieldType as any;
          const fieldTypeStr =
            typeof fieldType === "string"
              ? fieldType
              : fieldType?.toString() || "string";
          const isOptional = "optional" in prop ? (prop as any).optional : false;
          const isRelation =
            !/^[A-Z]/.test(fieldTypeStr) && typeof fieldType !== "string";

          return {
            name: prop.name,
            type: mapPrismaTypeToTsType(fieldTypeStr),
            isId: hasAttribute(prop, "id"),
            isRequired: !(isOptional || hasAttribute(prop, "default")),
            isUnique: hasAttribute(prop, "unique"),
            isRelation,
            hasDefault: hasAttribute(prop, "default"),
            isAutoGenerated: this.isFieldAutoGenerated(prop),
          };
        });

      return {
        name: model.name,
        fields,
      };
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        logger.error(
          `Prisma schema file not found at: ${path.relative(process.cwd(), this.schemaPath)}`,
        );
      } else {
        logger.error("Failed to parse Prisma schema", { error });
      }
      throw new Error(
        `Could not process Prisma schema. Make sure '${path.relative(process.cwd(), this.schemaPath)}' exists and is valid.`,
      );
    }
  }

  public async listModels(): Promise<string[]> {
    try {
      const schemaContent = await readFile(this.schemaPath, "utf-8");
      const ast = getSchema(schemaContent);

      return ast.list
        .filter((node): node is Model => node.type === "model")
        .map((model) => model.name);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        logger.warn(
          `Prisma schema file not found at: ${path.relative(process.cwd(), this.schemaPath)}`,
        );
        return [];
      }
      logger.error("Failed to parse Prisma schema for model listing", {
        error,
      });
      throw new Error(
        `Could not process Prisma schema. Make sure '${path.relative(process.cwd(), this.schemaPath)}' exists and is valid.`,
      );
    }
  }

  private isFieldAutoGenerated(prop: Property): boolean {
    if (hasAttribute(prop, "updatedAt")) {
      return true;
    }

    if (prop.type === "field" && Array.isArray(prop.attributes)) {
      const defaultAttr = prop.attributes.find(
        (attribute) => attribute.name === "default",
      );
      if (defaultAttr && Array.isArray(defaultAttr.args)) {
        const defaultValue = defaultAttr.args[0]?.value;
        if (
          typeof defaultValue === "string" &&
          ["autoincrement()", "now()", "cuid()", "uuid()"].includes(
            defaultValue,
          )
        ) {
          return true;
        }
      }
    }

    return false;
  }
}
