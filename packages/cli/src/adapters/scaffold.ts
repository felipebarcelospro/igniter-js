import * as fs from 'fs/promises'
import * as path from 'path'
import chalk from 'chalk'
import { createChildLogger } from './logger'
import { PrismaProvider } from './scaffold/providers/prisma'
import { DrizzleProvider } from './scaffold/providers/drizzle'
import { SchemaProvider, ModelSchema } from './scaffold/providers/base'
import { renderTemplate, toPascalCase, toCamelCase } from '../lib/template-helper'

const logger = createChildLogger({ component: 'scaffold' })

// --- Helper Functions ---

/**
 * Check if a Drizzle schema file exists in the current project
 */
async function hasDrizzleSchema(): Promise<boolean> {
  const possiblePaths = [
    path.join(process.cwd(), 'src', 'db', 'schema.ts'),
    path.join(process.cwd(), 'src', 'schema.ts'),
    path.join(process.cwd(), 'drizzle', 'schema.ts'),
    path.join(process.cwd(), 'db', 'schema.ts'),
  ]
  
  for (const schemaPath of possiblePaths) {
    try {
      await fs.access(schemaPath)
      return true
    } catch {
      // Continue checking other paths
    }
  }
  
  return false
}

/**
 * Get available Drizzle tables from the schema
 */
async function getDrizzleModels(): Promise<string[]> {
  try {
    const provider = new DrizzleProvider()
    return await provider.listModels()
  } catch (error) {
    logger.debug('Failed to get Drizzle models', { error })
    return []
  }
}

/**
 * Check if a Prisma schema file exists in the current project
 */
async function hasPrismaSchema(): Promise<boolean> {
  const possiblePaths = [
    path.join(process.cwd(), 'prisma', 'schema.prisma'),
    path.join(process.cwd(), 'schema.prisma')
  ]
  
  for (const schemaPath of possiblePaths) {
    try {
      await fs.access(schemaPath)
      return true
    } catch {
      // Continue checking other paths
    }
  }
  
  return false
}

/**
 * Get available Prisma models from the schema
 */
async function getPrismaModels(): Promise<string[]> {
  try {
    const provider = new PrismaProvider()
    return await provider.listModels()
  } catch (error) {
    logger.debug('Failed to get Prisma models', { error })
    return []
  }
}

async function writeFile(filePath: string, content: string): Promise<void> {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  await fs.writeFile(filePath, content, 'utf-8');
}


// --- CRUD Template Generators (using Handlebars) ---

async function generateCrudInterfacesTemplate(model: ModelSchema, featureName: string, providerName: string): Promise<string> {
  const modelNamePascal = toPascalCase(model.name);

  const fields = model.fields
    .filter(field => !field.isRelation)
    .map(field => {
      let zodType: string;
      switch (field.type) {
        case 'string':
        case 'bigint':
          zodType = 'z.string()';
          break;
        case 'number':
          zodType = 'z.number()';
          break;
        case 'boolean':
          zodType = 'z.boolean()';
          break;
        case 'Date':
          zodType = 'z.date()';
          break;
        default:
          zodType = `z.any() // Type '${field.type}' not directly supported`;
      }
      if (!field.isRequired) {
        zodType += '.nullable()';
      }
      return {
        name: field.name,
        zodType
      };
    });

  const omitFields = model.fields
    .filter(f => f.isId || f.isAutoGenerated)
    .map(f => f.name);

  return renderTemplate('interfaces.crud.hbs', {
    modelName: model.name,
    modelNamePascal,
    providerName,
    fields,
    omitFields
  });
}


async function generateCrudProcedureTemplate(model: ModelSchema, featureName: string): Promise<string> {
  const modelNameCamel = toCamelCase(model.name);
  const modelNamePascal = toPascalCase(model.name);
  const idField = model.fields.find(f => f.isId);
  if (!idField) throw new Error(`Model ${model.name} has no ID field.`);

  return renderTemplate('procedure.crud.hbs', {
    modelNameCamel,
    modelNamePascal,
    featureName,
    idFieldType: idField.type
  });
}

async function generateCrudControllerTemplate(model: ModelSchema, featureName: string): Promise<string> {
  const modelNameCamel = toCamelCase(model.name);
  const modelNamePascal = toPascalCase(model.name);

  return renderTemplate('controller.crud.hbs', {
    modelNameCamel,
    modelNamePascal,
    featureName
  });
}

async function generateCrudIndexTemplate(featureName: string): Promise<string> {
  return renderTemplate('index.crud.hbs', { featureName });
}


// --- Empty Feature Template Generators (using Handlebars) ---

async function generateEmptyControllerTemplate(featureName: string): Promise<string> {
  const controllerName = `${featureName.toLowerCase()}Controller`;
  return renderTemplate('controller.empty.hbs', {
    featureName,
    controllerName
  });
}

async function generateEmptyInterfacesTemplate(featureName: string): Promise<string> {
  return renderTemplate('interfaces.empty.hbs', { featureName });
}

async function generateEmptyIndexTemplate(featureName: string): Promise<string> {
  return renderTemplate('index.empty.hbs', { featureName });
}

// --- Main Scaffolding Logic ---

async function scaffoldEmptyFeature(featureName: string, featureDir: string) {
    logger.info(`Creating empty feature '${featureName}'...`)

    try {
        await fs.mkdir(path.join(featureDir, 'controllers'), { recursive: true })
        await fs.mkdir(path.join(featureDir, 'procedures'), { recursive: true })

        await writeFile(
            path.join(featureDir, 'controllers', `${featureName}.controller.ts`),
            await generateEmptyControllerTemplate(featureName)
        )
        await writeFile(
            path.join(featureDir, `${featureName}.interfaces.ts`),
            await generateEmptyInterfacesTemplate(featureName)
        )
        await writeFile(
            path.join(featureDir, 'index.ts'),
            await generateEmptyIndexTemplate(featureName)
        )
        logger.success(`Scaffolded empty feature '${featureName}'`)
    } catch(error) {
        logger.error(`Failed to create empty feature '${featureName}'`)
        throw error
    }
}


async function scaffoldFeatureFromSchema(featureName: string, schemaString: string, featureDir: string) {
    logger.info(`Scaffolding feature '${featureName}' from schema...`)

    try {
        const [providerName, modelName] = schemaString.split(':')
        if (!providerName || !modelName) {
            throw new Error('Invalid schema format. Expected `provider:ModelName` (e.g., `prisma:User` or `drizzle:users`).')
        }

        const provider = getSchemaProvider(providerName)
        const model = await provider.getModel(modelName)

        if (!model) {
            throw new Error(`Model '${modelName}' not found using provider '${providerName}'.`)
        }

        logger.info('Generating files from model schema...')

        await fs.mkdir(path.join(featureDir, 'controllers'), { recursive: true })
        await fs.mkdir(path.join(featureDir, 'procedures'), { recursive: true })

        await writeFile(
            path.join(featureDir, `${featureName}.interfaces.ts`),
            await generateCrudInterfacesTemplate(model, featureName, providerName)
        )
        await writeFile(
            path.join(featureDir, 'procedures', `${featureName}.procedure.ts`),
            await generateCrudProcedureTemplate(model, featureName)
        )
        await writeFile(
            path.join(featureDir, 'controllers', `${featureName}.controller.ts`),
            await generateCrudControllerTemplate(model, featureName)
        )
        await writeFile(
            path.join(featureDir, 'index.ts'),
            await generateCrudIndexTemplate(featureName)
        )

        logger.success(`Successfully scaffolded feature '${featureName}' from '${modelName}' model.`)
        console.log(chalk.cyan(`\n✅ Next step: Register the '${toCamelCase(featureName)}Controller' in 'src/igniter.router.ts'`))

    } catch (error) {
        logger.error(`Failed to scaffold feature from schema`)
        throw error
    }
}


export async function handleGenerateFeature(
  name: string | undefined,
  options: { schema?: string } = {}
): Promise<void> {
  const clack = await import('@clack/prompts')
  let featureName = name
  
  // Interactive wizard when no name is provided
  if (!featureName) {
    clack.intro(chalk.cyan('Generate Feature'))
    
    // Check available schema providers
    const hasPrisma = await hasPrismaSchema()
    const hasDrizzle = await hasDrizzleSchema()
    const prismaModels = hasPrisma ? await getPrismaModels() : []
    const drizzleModels = hasDrizzle ? await getDrizzleModels() : []
    
    // Ask for feature name
    featureName = await clack.text({
      message: 'What is the name of your feature?',
      placeholder: 'e.g., user, product, post',
      validate: (input) => {
        if (!input.trim()) {
          return 'Feature name is required'
        }
        if (!/^[a-zA-Z][a-zA-Z0-9-_]*$/.test(input)) {
          return 'Feature name must start with a letter and contain only letters, numbers, hyphens, and underscores'
        }
        return undefined
      }
    }) as string
    
    if (clack.isCancel(featureName)) {
      clack.cancel('Operation cancelled.')
      process.exit(0)
    }
    
    // If schema providers are available, offer model selection
    if ((hasPrisma && prismaModels.length > 0) || (hasDrizzle && drizzleModels.length > 0)) {
      const useModelChoice = await clack.select({
        message: 'Would you like to generate CRUD operations from a schema model?',
        options: [
          { value: 'none', label: 'No, create an empty feature' },
          ...(hasPrisma && prismaModels.length > 0 ? [{ value: 'prisma', label: 'Yes, from a Prisma model' }] : []),
          ...(hasDrizzle && drizzleModels.length > 0 ? [{ value: 'drizzle', label: 'Yes, from a Drizzle table' }] : []),
        ]
      })
      
      if (clack.isCancel(useModelChoice)) {
        clack.cancel('Operation cancelled.')
        process.exit(0)
      }
      
      if (useModelChoice === 'prisma') {
        const selectedModel = await clack.select({
          message: 'Which Prisma model would you like to use?',
          options: prismaModels.map(model => ({ value: model, label: model }))
        })
        
        if (clack.isCancel(selectedModel)) {
          clack.cancel('Operation cancelled.')
          process.exit(0)
        }
        
        options.schema = `prisma:${selectedModel}`
      } else if (useModelChoice === 'drizzle') {
        const selectedModel = await clack.select({
          message: 'Which Drizzle table would you like to use?',
          options: drizzleModels.map(model => ({ value: model, label: model }))
        })
        
        if (clack.isCancel(selectedModel)) {
          clack.cancel('Operation cancelled.')
          process.exit(0)
        }
        
        options.schema = `drizzle:${selectedModel}`
      }
    }
  }
  
  // At this point, featureName is guaranteed to be defined
  const normalizedName = featureName!.toLowerCase()
  const featureDir = path.join(process.cwd(), 'src', 'features', normalizedName)

  logger.info(`Scaffolding feature: ${chalk.cyan(normalizedName)}`)

  try {
    await fs.access(featureDir)
    logger.error(`Feature '${normalizedName}' already exists.`)
    console.error(chalk.red(`✗ Feature '${normalizedName}' already exists at ${path.relative(process.cwd(), featureDir)}`))
    return
  } catch (error) {
    // Directory does not exist, which is what we want.
  }

  if (options.schema) {
    await scaffoldFeatureFromSchema(normalizedName, options.schema, featureDir)
  } else {
    await scaffoldEmptyFeature(normalizedName, featureDir)
  }
}

// Stub for future commands
export async function handleGenerateController(name: string, feature: string): Promise<void> {
    logger.warn(`'generate controller' is not yet fully implemented. Use 'generate feature --schema' instead.`)
}
export async function handleGenerateProcedure(name: string, feature: string): Promise<void> {
    logger.warn(`'generate procedure' is not yet fully implemented. Use 'generate feature --schema' instead.`)
}
