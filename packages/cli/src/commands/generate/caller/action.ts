import { promises as fs } from "fs";
import path from "path";
import * as p from "@clack/prompts";
import yaml from "js-yaml";
import SwaggerParser from "@apidevtools/swagger-parser";
import type { OpenAPIV3, OpenAPIV3_1 } from "openapi-types";
import { Casing } from "@/utils/casing";

type OpenApiDoc = OpenAPIV3.Document | OpenAPIV3_1.Document;

type GenerateCallerOptions = {
  name?: string;
  url?: string;
  path?: string;
  output?: string;
};

const SUPPORTED_METHODS = ["get", "post", "put", "patch", "delete"] as const;
type SupportedMethod = (typeof SUPPORTED_METHODS)[number];

export async function handleGenerateCallerAction(
  options: GenerateCallerOptions,
): Promise<void> {
  p.intro("Generate Igniter Caller");

  try {
    const callerName = await resolveCallerName(options.name);
    const source = await resolveSource(options);

    const spinner = p.spinner();
    spinner.start("Loading OpenAPI spec...");

    const parsedDoc = await loadOpenApiDocument(source);
    const host = deriveHostname(source, parsedDoc) || "api";
    const outputDir = path.resolve(
      process.cwd(),
      options.output ?? path.join("src", "callers", host),
    );

    const prefix = Casing.toPascalCase(callerName);
    const converter = new SchemaConverter(prefix, parsedDoc.components);

    const componentsCode = converter.renderComponentSchemas();
    const schemasObject = buildSchemasObject(parsedDoc, converter);
    const schemaConstName = `${prefix}Schema`;
    const schemaTypeName = `${prefix}SchemaType`;

    const schemaFileContents = [
      "/* eslint-disable */",
      "/* prettier-ignore */",
      "/**",
      " * @generated by @igniter-js/cli",
      " * This file was automatically created from your OpenAPI spec.",
      " * Do not edit manually; regenerate via `igniter generate caller`.",
      " */",
      'import { z } from "zod";',
      componentsCode,
      `const schemas = ${schemasObject} as const;`,
      "",
      `export const ${schemaConstName} = schemas;`,
      `export type ${schemaTypeName} = typeof ${schemaConstName};`,
      "",
    ]
      .filter(Boolean)
      .join("\n");

    const baseUrl = inferBaseUrl(source, parsedDoc);
    const callerVar = `${Casing.toCamelCase(callerName)}Caller`;
    const callerFileContents = [
      "/**",
      ` * Preconfigured IgniterCaller for ${prefix}.`,
      " * Regenerate via `igniter generate caller` when the OpenAPI spec changes.",
      " */",
      'import { IgniterCaller } from "@igniter-js/caller";',
      `import { ${schemaConstName} } from "./schema";`,
      "",
      "export const " + callerVar + " = IgniterCaller.create()",
      baseUrl ? `  .withBaseUrl("${baseUrl}")` : "",
      "  .withSchemas(" + schemaConstName + ", { mode: \"strict\" })",
      "  .build();",
      "",
    ]
      .filter(Boolean)
      .join("\n");

    await fs.mkdir(outputDir, { recursive: true });
    await fs.writeFile(path.join(outputDir, "schema.ts"), schemaFileContents, "utf8");
    await fs.writeFile(path.join(outputDir, "index.ts"), callerFileContents, "utf8");

    spinner.stop("Caller generated successfully.");
    p.log.success(
      `Schemas and caller created at ${path.relative(process.cwd(), outputDir)}`,
    );
    p.log.info(`Exported caller: ${callerVar} (schemas: ${schemaConstName})`);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    p.log.error(message);
    process.exit(1);
  }
}

type CallerSource =
  | { type: "url"; url: string }
  | { type: "path"; path: string };

async function resolveCallerName(name?: string): Promise<string> {
  if (name) {
    return name.trim();
  }

  const answer = await p.text({
    message: "Caller name (e.g., facebook, billing)",
    validate: (value) =>
      value && value.trim().length > 0 ? undefined : "Name is required",
  });

  if (p.isCancel(answer)) {
    p.cancel("Caller generation cancelled.");
    process.exit(0);
  }

  return String(answer);
}

async function resolveSource(
  options: GenerateCallerOptions,
): Promise<CallerSource> {
  if (options.url && options.path) {
    throw new Error("Use either --url or --path, not both.");
  }

  if (options.url) {
    return { type: "url", url: options.url };
  }
  if (options.path) {
    return { type: "path", path: options.path };
  }

  const sourceChoice = await p.select({
    message: "Where is your OpenAPI spec?",
    options: [
      { label: "Remote URL", value: "url" },
      { label: "Local file path", value: "path" },
    ],
    initialValue: "url",
  });

  if (p.isCancel(sourceChoice)) {
    p.cancel("Caller generation cancelled.");
    process.exit(0);
  }

  if (sourceChoice === "url") {
    const url = await p.text({
      message: "OpenAPI URL",
      placeholder: "https://api.example.com/openapi.json",
      validate: (value) => (!value ? "URL is required" : undefined),
    });
    if (p.isCancel(url)) {
      p.cancel("Caller generation cancelled.");
      process.exit(0);
    }
    return { type: "url", url: String(url) };
  }

  const filePath = await p.text({
    message: "Path to OpenAPI file",
    placeholder: "./openapi.json",
    validate: (value) => (!value ? "Path is required" : undefined),
  });
  if (p.isCancel(filePath)) {
    p.cancel("Caller generation cancelled.");
    process.exit(0);
  }
  return { type: "path", path: String(filePath) };
}

async function loadOpenApiDocument(source: CallerSource): Promise<OpenApiDoc> {
  const raw = await loadRawContent(source);
  const parsed = parseOpenApi(raw);

  const version = parsed.openapi ?? "";
  if (typeof version !== "string" || !version.startsWith("3.")) {
    throw new Error("Only OpenAPI 3.x documents are supported.");
  }

  const bundled = (await SwaggerParser.bundle(parsed as any)) as OpenApiDoc;
  return bundled;
}

async function loadRawContent(source: CallerSource): Promise<string> {
  if (source.type === "url") {
    const response = await fetch(source.url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch OpenAPI document: ${response.status} ${response.statusText}`,
      );
    }
    return await response.text();
  }

  const filePath = path.resolve(process.cwd(), source.path);
  return await fs.readFile(filePath, "utf8");
}

function parseOpenApi(content: string): any {
  try {
    return JSON.parse(content);
  } catch {
    const parsed = yaml.load(content);
    if (!parsed || typeof parsed !== "object") {
      throw new Error("Could not parse OpenAPI document (JSON/YAML).");
    }
    return parsed;
  }
}

function deriveHostname(source: CallerSource, doc: OpenApiDoc): string | null {
  if (source.type === "url") {
    try {
      const url = new URL(source.url);
      return url.hostname.replace(/[^a-zA-Z0-9.-]/g, "") || null;
    } catch {
      return null;
    }
  }

  const serverUrl = doc.servers?.[0]?.url;
  if (serverUrl) {
    try {
      const url = new URL(serverUrl);
      return url.hostname.replace(/[^a-zA-Z0-9.-]/g, "") || null;
    } catch {
      return null;
    }
  }

  return null;
}

function inferBaseUrl(source: CallerSource, doc: OpenApiDoc): string | null {
  if (source.type === "url") {
    const serverUrl = doc.servers?.[0]?.url;
    if (serverUrl) {
      return serverUrl;
    }
    return new URL(source.url).origin;
  }

  const serverUrl = doc.servers?.[0]?.url;
  return serverUrl ?? null;
}

class SchemaConverter {
  private readonly prefix: string;
  private readonly components: OpenAPIV3.ComponentsObject | OpenAPIV3_1.ComponentsObject | undefined;
  private readonly generated: Map<string, string> = new Map();
  private readonly inProgress: Set<string> = new Set();

  constructor(prefix: string, components?: OpenAPIV3.ComponentsObject | OpenAPIV3_1.ComponentsObject) {
    this.prefix = prefix;
    this.components = components;
  }

  public renderComponentSchemas(): string {
    const entries: string[] = [];
    const names = Object.keys(this.components?.schemas ?? {}).sort();
    for (const name of names) {
      const identifier = this.componentIdentifier(name);
      const expression = this.convertWithCache(name);
      entries.push(`const ${identifier} = ${expression};`);
    }
    return entries.length ? `${entries.join("\n")}\n\n` : "";
  }

  public convert(schema: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject | OpenAPIV3_1.SchemaObject): string {
    if ("$ref" in schema) {
      const refName = this.refName(schema.$ref);
      const identifier = this.componentIdentifier(refName);
      this.convertWithCache(refName);
      return this.wrapLazyIfNeeded(refName, identifier);
    }

    const schemaType = Array.isArray(schema.type) ? schema.type[0] : schema.type;
    const nullable = isNullable(schema);

    if (schema.oneOf?.length) {
      const parts = schema.oneOf.map((item) => this.convert(item));
      return wrapNullable(`z.union([${parts.join(", ")}])`, nullable);
    }

    if (schema.anyOf?.length) {
      const parts = schema.anyOf.map((item) => this.convert(item));
      return wrapNullable(`z.union([${parts.join(", ")}])`, nullable);
    }

    if (schema.allOf?.length) {
      const [first, ...rest] = schema.allOf;
      let expr = this.convert(first);
      for (const part of rest) {
        expr = `z.intersection(${expr}, ${this.convert(part)})`;
      }
      return wrapNullable(expr, nullable);
    }

    switch (schemaType) {
      case "string":
        if (schema.enum) {
          const values = schema.enum.map((v) => JSON.stringify(String(v)));
          return wrapNullable(`z.enum([${values.join(", ")}])`, nullable);
        }
        return wrapNullable("z.string()", nullable);
      case "number":
      case "integer": {
        let expr = "z.number()";
        if (schemaType === "integer") {
          expr = `${expr}.int()`;
        }
        return wrapNullable(expr, nullable);
      }
      case "boolean":
        return wrapNullable("z.boolean()", nullable);
      case "array": {
        const arraySchema = schema as OpenAPIV3.ArraySchemaObject | OpenAPIV3_1.ArraySchemaObject;
        const items = arraySchema.items ? this.convert(arraySchema.items as any) : "z.unknown()";
        return wrapNullable(`z.array(${items})`, nullable);
      }
      case "object": {
        const properties = schema.properties ?? {};
        const required = new Set(schema.required ?? []);
        const entries = Object.entries(properties).map(([key, value]) => {
          const valueExpr = this.convert(value as any);
          return `${JSON.stringify(key)}: ${required.has(key) ? valueExpr : `${valueExpr}.optional()`}`;
        });

        let base = `z.object({${entries.length ? ` ${entries.join(", ")} ` : ""}})`;

        if (schema.additionalProperties) {
          const apValue =
            schema.additionalProperties === true
              ? "z.unknown()"
              : this.convert(schema.additionalProperties as any);
          base = `${base}.catchall(${apValue})`;
        }

        return wrapNullable(base, nullable);
      }
      default:
        return "z.unknown()";
    }
  }

  private convertWithCache(name: string): string {
    const identifier = this.componentIdentifier(name);
    if (this.generated.has(name)) {
      return this.generated.get(name)!;
    }

    if (this.inProgress.has(name)) {
      return `z.lazy(() => ${identifier})`;
    }

    const schema = this.components?.schemas?.[name] as
      | OpenAPIV3.SchemaObject
      | OpenAPIV3.ReferenceObject
      | OpenAPIV3_1.SchemaObject
      | OpenAPIV3_1.ReferenceObject
      | undefined;
    if (!schema) {
      return "z.unknown()";
    }

    this.inProgress.add(name);
    const expression = this.convert(schema);
    this.inProgress.delete(name);

    this.generated.set(name, expression);
    return expression;
  }

  private componentIdentifier(name: string): string {
    return `${this.prefix}${Casing.toPascalCase(name)}Schema`;
  }

  private refName(ref: string): string {
    const [, component] = ref.split("#/components/schemas/");
    if (!component) {
      return "UnknownSchema";
    }
    return component;
  }

  private wrapLazyIfNeeded(name: string, identifier: string): string {
    if (this.inProgress.has(name)) {
      return `z.lazy(() => ${identifier})`;
    }
    return identifier;
  }
}

function buildSchemasObject(
  doc: OpenApiDoc,
  converter: SchemaConverter,
): string {
  const builder = new CodeBuilder();
  builder.line("{");

  const sortedPaths = Object.keys(doc.paths || {}).sort();
  for (const rawPath of sortedPaths) {
    const pathItem = doc.paths?.[rawPath];
    if (!pathItem) continue;

    const methodEntries: string[] = [];
    for (const method of SUPPORTED_METHODS) {
      const operation = (pathItem as Record<SupportedMethod, OpenAPIV3.OperationObject | OpenAPIV3_1.OperationObject | undefined>)[method];
      if (!operation) continue;

      const responses = buildResponses(operation.responses, converter, doc);
      const requestBody = buildRequestBody(operation.requestBody, converter, doc);

      const block: string[] = [];
      block.push(`${method.toUpperCase()}: {`);
      if (requestBody) {
        block.push(indent(`request: ${requestBody},`, 1));
      }
      block.push(indent("responses: {", 1));
      block.push(responses);
      block.push(indent("},", 1));
      block.push("},");

      methodEntries.push(indent(block.join("\n"), 2));
    }

    if (!methodEntries.length) continue;

    const normalizedPath = normalizePath(rawPath);
    builder.line(`  ${JSON.stringify(normalizedPath)}: {`);
    builder.line(methodEntries.join("\n"));
    builder.line("  },");
  }

  builder.line("}");
  return builder.toString();
}

function buildResponses(
  responses: OpenAPIV3.ResponsesObject | OpenAPIV3_1.ResponsesObject | undefined,
  converter: SchemaConverter,
  doc: OpenApiDoc,
): string {
  if (!responses || !Object.keys(responses).length) {
    return indent("", 2);
  }

  const builder = new CodeBuilder();
  const sorted = Object.keys(responses).sort();
  for (const status of sorted) {
    const responseOrRef = responses[status];
    if (!responseOrRef) continue;

    const resolved = resolveResponse(responseOrRef, doc);
    const schema = resolveSchemaFromResponse(resolved);
    const expression = schema ? converter.convert(schema) : "z.unknown()";

    builder.line(indent(`${formatStatusKey(status)}: ${expression},`, 3));
  }

  return builder.toString();
}

function buildRequestBody(
  requestBody:
    | OpenAPIV3.RequestBodyObject
    | OpenAPIV3.ReferenceObject
    | OpenAPIV3_1.RequestBodyObject
    | OpenAPIV3_1.ReferenceObject
    | undefined,
  converter: SchemaConverter,
  doc: OpenApiDoc,
): string | null {
  if (!requestBody) return null;

  const resolved =
    "$ref" in requestBody ? resolveRequestBody(requestBody, doc) : requestBody;
  if (!resolved?.content) return null;

  const schema = selectJsonSchema(resolved.content);
  if (!schema) return null;

  return converter.convert(schema);
}

function selectJsonSchema(
  content: Record<string, OpenAPIV3.MediaTypeObject | OpenAPIV3_1.MediaTypeObject>,
): OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | OpenAPIV3_1.SchemaObject | OpenAPIV3_1.ReferenceObject | undefined {
  if (content["application/json"]?.schema) {
    return content["application/json"].schema;
  }

  const first = Object.values(content)[0];
  return first?.schema;
}

function resolveSchemaFromResponse(
  response: OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject | undefined,
): OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | OpenAPIV3_1.SchemaObject | OpenAPIV3_1.ReferenceObject | undefined {
  if (!response?.content) {
    return undefined;
  }
  return selectJsonSchema(response.content);
}

function normalizePath(pathname: string): string {
  return pathname.replace(/{(.*?)}/g, ":$1");
}

function indent(value: string, depth: number): string {
  const pad = "  ".repeat(depth);
  return value
    .split("\n")
    .map((line) => (line ? pad + line : line))
    .join("\n");
}

function isNullable(schema: unknown): boolean {
  if (!schema || typeof schema !== "object") return false;
  return Boolean((schema as any).nullable);
}

function wrapNullable(expr: string, nullable?: boolean): string {
  return nullable ? `${expr}.nullable()` : expr;
}

function formatStatusKey(status: string): string {
  const trimmed = String(status).trim();
  const numeric = Number(trimmed);
  if (!Number.isNaN(numeric) && `${numeric}` === trimmed) {
    return trimmed;
  }
  return JSON.stringify(trimmed);
}

function resolveResponse(
  response: OpenAPIV3.ReferenceObject | OpenAPIV3.ResponseObject | OpenAPIV3_1.ReferenceObject | OpenAPIV3_1.ResponseObject,
  doc: OpenApiDoc,
): OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject | undefined {
  if ("$ref" in response) {
    return getComponent(doc, response.$ref, "responses");
  }
  return response;
}

function resolveRequestBody(
  requestBody: OpenAPIV3.ReferenceObject | OpenAPIV3_1.ReferenceObject,
  doc: OpenApiDoc,
): OpenAPIV3.RequestBodyObject | OpenAPIV3_1.RequestBodyObject | undefined {
  return getComponent(doc, requestBody.$ref, "requestBodies");
}

function getComponent<T>(
  doc: OpenApiDoc,
  ref: string,
  type: "responses" | "requestBodies",
): T | undefined {
  const match = ref.match(/^#\/components\/([^/]+)\/(.+)$/);
  if (!match) return undefined;
  const [, category, name] = match;
  if (category !== type) return undefined;
  const component = (doc as any).components?.[type]?.[name];
  return component as T | undefined;
}

class CodeBuilder {
  private readonly lines: string[] = [];

  line(text: string): void {
    this.lines.push(text);
  }

  toString(): string {
    return this.lines.join("\n");
  }
}
