import { promises as fs } from "fs";
import path from "path";
import * as p from "@clack/prompts";
import yaml from "js-yaml";
import SwaggerParser from "@apidevtools/swagger-parser";
import type { OpenAPIV3, OpenAPIV3_1 } from "openapi-types";
import { Casing } from "@/utils/casing";

type OpenApiDoc = OpenAPIV3.Document | OpenAPIV3_1.Document;

type GenerateCallerOptions = {
  name?: string;
  url?: string;
  path?: string;
  output?: string;
};

const SUPPORTED_METHODS = ["get", "post", "put", "patch", "delete", "head"] as const;
type SupportedMethod = (typeof SUPPORTED_METHODS)[number];

export async function handleGenerateCallerAction(
  options: GenerateCallerOptions,
): Promise<void> {
  p.intro("Generate Igniter Caller");

  try {
    const callerName = await resolveCallerName(options.name);
    const source = await resolveSource(options);

    const spinner = p.spinner();
    spinner.start("Loading OpenAPI spec...");

    const parsedDoc = await loadOpenApiDocument(source);
    const host = deriveHostname(source, parsedDoc) || "api";
    const outputDir = path.resolve(
      process.cwd(),
      options.output ?? path.join("src", "callers", host),
    );

    const prefix = Casing.toPascalCase(callerName);
    const converter = new SchemaConverter(prefix, parsedDoc.components);

    const componentsCode = converter.renderComponentSchemas();
    const schemaConstName = `${Casing.toCamelCase(callerName)}CallerSchemas`;
    const schemaTypeName = `${prefix}CallerSchemas`;
    const { builderCode, typeAliases } = buildSchemaBuilder(
      parsedDoc,
      converter,
      schemaConstName,
    );

    const schemaFileContents = [
      "/* eslint-disable */",
      "/* prettier-ignore */",
      "/**",
      " * @generated by @igniter-js/cli",
      " * This file was automatically created from your OpenAPI spec.",
      " * Do not edit manually; regenerate via `igniter generate caller`.",
      " */",
      'import { z } from "zod";',
      'import { IgniterCallerSchema } from "@igniter-js/caller";',
      componentsCode,
      builderCode,
      `export type ${schemaTypeName} = typeof ${schemaConstName};`,
      typeAliases,
      "",
    ]
      .filter(Boolean)
      .join("\n");

    const baseUrl = inferBaseUrl(source, parsedDoc);
    const callerVar = `${Casing.toCamelCase(callerName)}Caller`;
    const callerFileContents = [
      "/**",
      ` * Preconfigured IgniterCaller for ${prefix}.`,
      " * Regenerate via `igniter generate caller` when the OpenAPI spec changes.",
      " */",
      'import { IgniterCaller } from "@igniter-js/caller";',
      `import { ${schemaConstName} } from "./schema";`,
      "",
      "export const " + callerVar + " = IgniterCaller.create()",
      baseUrl ? `  .withBaseUrl("${baseUrl}")` : "",
      "  .withSchemas(" + schemaConstName + ", { mode: \"strict\" })",
      "  .build();",
      "",
    ]
      .filter(Boolean)
      .join("\n");

    await fs.mkdir(outputDir, { recursive: true });
    await fs.writeFile(path.join(outputDir, "schema.ts"), schemaFileContents, "utf8");
    await fs.writeFile(path.join(outputDir, "index.ts"), callerFileContents, "utf8");

    spinner.stop("Caller generated successfully.");
    p.log.success(
      `Schemas and caller created at ${path.relative(process.cwd(), outputDir)}`,
    );
    p.log.info(`Exported caller: ${callerVar} (schemas: ${schemaConstName})`);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    p.log.error(message);
    process.exit(1);
  }
}

type CallerSource =
  | { type: "url"; url: string }
  | { type: "path"; path: string };

async function resolveCallerName(name?: string): Promise<string> {
  if (name) {
    return name.trim();
  }

  const answer = await p.text({
    message: "Caller name (e.g., facebook, billing)",
    validate: (value) =>
      value && value.trim().length > 0 ? undefined : "Name is required",
  });

  if (p.isCancel(answer)) {
    p.cancel("Caller generation cancelled.");
    process.exit(0);
  }

  return String(answer);
}

async function resolveSource(
  options: GenerateCallerOptions,
): Promise<CallerSource> {
  if (options.url && options.path) {
    throw new Error("Use either --url or --path, not both.");
  }

  if (options.url) {
    return { type: "url", url: options.url };
  }
  if (options.path) {
    return { type: "path", path: options.path };
  }

  const sourceChoice = await p.select({
    message: "Where is your OpenAPI spec?",
    options: [
      { label: "Remote URL", value: "url" },
      { label: "Local file path", value: "path" },
    ],
    initialValue: "url",
  });

  if (p.isCancel(sourceChoice)) {
    p.cancel("Caller generation cancelled.");
    process.exit(0);
  }

  if (sourceChoice === "url") {
    const url = await p.text({
      message: "OpenAPI URL",
      placeholder: "https://api.example.com/openapi.json",
      validate: (value) => (!value ? "URL is required" : undefined),
    });
    if (p.isCancel(url)) {
      p.cancel("Caller generation cancelled.");
      process.exit(0);
    }
    return { type: "url", url: String(url) };
  }

  const filePath = await p.text({
    message: "Path to OpenAPI file",
    placeholder: "./openapi.json",
    validate: (value) => (!value ? "Path is required" : undefined),
  });
  if (p.isCancel(filePath)) {
    p.cancel("Caller generation cancelled.");
    process.exit(0);
  }
  return { type: "path", path: String(filePath) };
}

async function loadOpenApiDocument(source: CallerSource): Promise<OpenApiDoc> {
  const raw = await loadRawContent(source);
  const parsed = parseOpenApi(raw);

  const version = parsed.openapi ?? "";
  if (typeof version !== "string" || !version.startsWith("3.")) {
    throw new Error("Only OpenAPI 3.x documents are supported.");
  }

  const bundled = (await SwaggerParser.bundle(parsed as any)) as OpenApiDoc;
  return bundled;
}

async function loadRawContent(source: CallerSource): Promise<string> {
  if (source.type === "url") {
    const response = await fetch(source.url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch OpenAPI document: ${response.status} ${response.statusText}`,
      );
    }
    return await response.text();
  }

  const filePath = path.resolve(process.cwd(), source.path);
  return await fs.readFile(filePath, "utf8");
}

function parseOpenApi(content: string): any {
  try {
    return JSON.parse(content);
  } catch {
    const parsed = yaml.load(content);
    if (!parsed || typeof parsed !== "object") {
      throw new Error("Could not parse OpenAPI document (JSON/YAML).");
    }
    return parsed;
  }
}

function deriveHostname(source: CallerSource, doc: OpenApiDoc): string | null {
  if (source.type === "url") {
    try {
      const url = new URL(source.url);
      return url.hostname.replace(/[^a-zA-Z0-9.-]/g, "") || null;
    } catch {
      return null;
    }
  }

  const serverUrl = doc.servers?.[0]?.url;
  if (serverUrl) {
    try {
      const url = new URL(serverUrl);
      return url.hostname.replace(/[^a-zA-Z0-9.-]/g, "") || null;
    } catch {
      return null;
    }
  }

  return null;
}

function inferBaseUrl(source: CallerSource, doc: OpenApiDoc): string | null {
  if (source.type === "url") {
    const serverUrl = doc.servers?.[0]?.url;
    if (serverUrl) {
      return serverUrl;
    }
    return new URL(source.url).origin;
  }

  const serverUrl = doc.servers?.[0]?.url;
  return serverUrl ?? null;
}

class SchemaConverter {
  private readonly prefix: string;
  private readonly components: OpenAPIV3.ComponentsObject | OpenAPIV3_1.ComponentsObject | undefined;
  private readonly generated: Map<string, string> = new Map();
  private readonly inProgress: Set<string> = new Set();

  constructor(prefix: string, components?: OpenAPIV3.ComponentsObject | OpenAPIV3_1.ComponentsObject) {
    this.prefix = prefix;
    this.components = components;
  }

  public renderComponentSchemas(): string {
    const entries: string[] = [];
    const names = this.listComponents();
    for (const name of names) {
      const identifier = this.componentIdentifier(name);
      const expression = this.convertWithCache(name);
      const registryKey = this.registryKey(name);
      entries.push(
        [
          "/**",
          ` * Schema: ${registryKey}`,
          ` * Source: openapi#/components/schemas/${name}`,
          " */",
          `const ${identifier} = ${expression};`,
          "",
        ].join("\n"),
      );
    }
    return entries.length ? `${entries.join("\n")}\n` : "";
  }

  public listComponents(): string[] {
    return Object.keys(this.components?.schemas ?? {}).sort();
  }

  public registryKey(name: string): string {
    return Casing.toPascalCase(name);
  }

  public componentName(name: string): string {
    return this.componentIdentifier(name);
  }

  public convert(schema: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject | OpenAPIV3_1.SchemaObject): string {
    if ("$ref" in schema) {
      const refName = this.refName(schema.$ref);
      const identifier = this.componentIdentifier(refName);
      this.convertWithCache(refName);
      return this.wrapLazyIfNeeded(refName, identifier);
    }

    const schemaType = Array.isArray(schema.type) ? schema.type[0] : schema.type;
    const nullable = isNullable(schema);

    if (schema.oneOf?.length) {
      const parts = schema.oneOf.map((item) => this.convert(item));
      return wrapNullable(`z.union([${parts.join(", ")}])`, nullable);
    }

    if (schema.anyOf?.length) {
      const parts = schema.anyOf.map((item) => this.convert(item));
      return wrapNullable(`z.union([${parts.join(", ")}])`, nullable);
    }

    if (schema.allOf?.length) {
      const [first, ...rest] = schema.allOf;
      let expr = this.convert(first);
      for (const part of rest) {
        expr = `z.intersection(${expr}, ${this.convert(part)})`;
      }
      return wrapNullable(expr, nullable);
    }

    switch (schemaType) {
      case "string":
        if (schema.enum) {
          const values = schema.enum.map((v) => JSON.stringify(String(v)));
          return wrapNullable(`z.enum([${values.join(", ")}])`, nullable);
        }
        return wrapNullable("z.string()", nullable);
      case "number":
      case "integer": {
        let expr = "z.number()";
        if (schemaType === "integer") {
          expr = `${expr}.int()`;
        }
        return wrapNullable(expr, nullable);
      }
      case "boolean":
        return wrapNullable("z.boolean()", nullable);
      case "array": {
        const arraySchema = schema as OpenAPIV3.ArraySchemaObject | OpenAPIV3_1.ArraySchemaObject;
        const items = arraySchema.items ? this.convert(arraySchema.items as any) : "z.unknown()";
        return wrapNullable(`z.array(${items})`, nullable);
      }
      case "object": {
        const properties = schema.properties ?? {};
        const required = new Set(schema.required ?? []);
        const entries = Object.entries(properties).map(([key, value]) => {
          const valueExpr = this.convert(value as any);
          return `${JSON.stringify(key)}: ${required.has(key) ? valueExpr : `${valueExpr}.optional()`}`;
        });

        let base = `z.object({${entries.length ? ` ${entries.join(", ")} ` : ""}})`;

        if (schema.additionalProperties) {
          const apValue =
            schema.additionalProperties === true
              ? "z.unknown()"
              : this.convert(schema.additionalProperties as any);
          base = `${base}.catchall(${apValue})`;
        }

        return wrapNullable(base, nullable);
      }
      default:
        return "z.unknown()";
    }
  }

  private convertWithCache(name: string): string {
    const identifier = this.componentIdentifier(name);
    if (this.generated.has(name)) {
      return this.generated.get(name)!;
    }

    if (this.inProgress.has(name)) {
      return `z.lazy(() => ${identifier})`;
    }

    const schema = this.components?.schemas?.[name] as
      | OpenAPIV3.SchemaObject
      | OpenAPIV3.ReferenceObject
      | OpenAPIV3_1.SchemaObject
      | OpenAPIV3_1.ReferenceObject
      | undefined;
    if (!schema) {
      return "z.unknown()";
    }

    this.inProgress.add(name);
    const expression = this.convert(schema);
    this.inProgress.delete(name);

    this.generated.set(name, expression);
    return expression;
  }

  private componentIdentifier(name: string): string {
    return `${this.prefix}${Casing.toPascalCase(name)}Schema`;
  }

  private refName(ref: string): string {
    const [, component] = ref.split("#/components/schemas/");
    if (!component) {
      return "UnknownSchema";
    }
    return component;
  }

  private wrapLazyIfNeeded(name: string, identifier: string): string {
    if (this.inProgress.has(name)) {
      return `z.lazy(() => ${identifier})`;
    }
    return identifier;
  }
}

type ResponseDocEntry = {
  status: string;
  statusLiteral: string;
  label: string;
};

type SchemaExpression = {
  expression: string;
  label: string;
  usesVoid: boolean;
};

type OperationDescriptor = {
  path: string;
  method: string;
  request: boolean;
  responses: ResponseDocEntry[];
  typeName: string;
};

function buildSchemaBuilder(
  doc: OpenApiDoc,
  converter: SchemaConverter,
  schemaConstName: string,
): { builderCode: string; typeAliases: string } {
  const usedNames = new Map<string, number>();
  const operations: OperationDescriptor[] = [];
  const pathBlocks: string[] = [];
  let needsVoid = false;

  const sortedPaths = Object.keys(doc.paths || {}).sort();
  for (const rawPath of sortedPaths) {
    const pathItem = doc.paths?.[rawPath];
    if (!pathItem) continue;

    const methodBlocks: string[] = [];
    for (const method of SUPPORTED_METHODS) {
      const operation = (pathItem as Record<
        SupportedMethod,
        OpenAPIV3.OperationObject | OpenAPIV3_1.OperationObject | undefined
      >)[method];
      if (!operation) continue;

      const normalizedPath = normalizePath(rawPath);
      const requestBody = buildRequestBody(
        operation.requestBody,
        converter,
        doc,
      );
      const responses = buildResponses(operation.responses, converter, doc);

      const typeBaseName = ensureUniqueTypeName(
        buildOperationTypeName(rawPath, method, operation.operationId),
        usedNames,
      );

      operations.push({
        path: normalizedPath,
        method: method.toUpperCase(),
        request: Boolean(requestBody),
        responses: responses.entries,
        typeName: typeBaseName,
      });

      const docBlock = buildMethodDocBlock({
        method: method.toUpperCase(),
        path: normalizedPath,
        summary: operation.summary ?? operation.description,
        tags: operation.tags,
        operationId: operation.operationId,
        requestLabel: requestBody?.label,
        responses: responses.entries,
        source: `openapi#/paths/${encodeJsonPointerPath(rawPath)}/${method}`,
      });

      const methodCall = buildMethodCall(method, {
        request: requestBody?.expression,
        responses: responses.code,
        doc: operation.summary ?? operation.description,
        tags: operation.tags,
        operationId: operation.operationId,
      });

      methodBlocks.push(indent(`${docBlock}\n${methodCall}`, 3));
      needsVoid = needsVoid || responses.usesVoid;
    }

    if (!methodBlocks.length) continue;

    const normalizedPath = normalizePath(rawPath);
    const pathLines = [
      `  .path(${JSON.stringify(normalizedPath)}, (path) =>`,
      "    path",
      methodBlocks.join("\n"),
      "  )",
    ];

    pathBlocks.push(pathLines.join("\n"));
  }

  const builderLines: string[] = [];
  builderLines.push(`export const ${schemaConstName} = IgniterCallerSchema.create()`);

  const componentNames = converter.listComponents();
  for (const name of componentNames) {
    const registryKey = converter.registryKey(name);
    const identifier = converter.componentName(name);
    builderLines.push(`  .schema(${JSON.stringify(registryKey)}, ${identifier})`);
  }

  if (needsVoid) {
    builderLines.push(`  .schema("Void", z.void(), { internal: true })`);
  }

  if (pathBlocks.length) {
    builderLines.push(pathBlocks.join("\n"));
  }

  builderLines.push("  .build()");

  return {
    builderCode: `${builderLines.join("\n")}\n`,
    typeAliases: buildTypeAliases(operations, schemaConstName),
  };
}

function buildMethodDocBlock(params: {
  method: string;
  path: string;
  summary?: string;
  tags?: string[];
  operationId?: string;
  requestLabel?: string;
  responses: ResponseDocEntry[];
  source: string;
}): string {
  const lines: string[] = [];
  lines.push("/**");
  lines.push(` * ${params.method} ${params.path}`);
  if (params.summary) {
    lines.push(` * Summary: ${params.summary}`);
  }
  if (params.tags?.length) {
    lines.push(` * Tags: ${params.tags.join(", ")}`);
  }
  if (params.operationId) {
    lines.push(` * OperationId: ${params.operationId}`);
  }
  if (params.requestLabel) {
    lines.push(` * Request: ${params.requestLabel}`);
  }
  if (params.responses.length) {
    lines.push(" * Responses:");
    for (const response of params.responses) {
      lines.push(` *  - ${response.status}: ${response.label}`);
    }
  }
  lines.push(` * Source: ${params.source}`);
  lines.push(" */");
  return lines.join("\n");
}

function buildMethodCall(
  method: SupportedMethod,
  params: {
    request?: string;
    responses: string;
    doc?: string;
    tags?: string[];
    operationId?: string;
  },
): string {
  const lines: string[] = [];
  lines.push(`.${method}({`);
  if (params.request) {
    lines.push(`  request: ${params.request},`);
  }
  lines.push("  responses: {");
  lines.push(params.responses);
  lines.push("  },");
  if (params.doc) {
    lines.push(`  doc: ${JSON.stringify(params.doc)},`);
  }
  if (params.tags?.length) {
    lines.push(`  tags: ${JSON.stringify(params.tags)},`);
  }
  if (params.operationId) {
    lines.push(`  operationId: ${JSON.stringify(params.operationId)},`);
  }
  lines.push("})");
  return lines.join("\n");
}

function buildResponses(
  responses: OpenAPIV3.ResponsesObject | OpenAPIV3_1.ResponsesObject | undefined,
  converter: SchemaConverter,
  doc: OpenApiDoc,
): { code: string; entries: ResponseDocEntry[]; usesVoid: boolean } {
  const builder = new CodeBuilder();
  const entries: ResponseDocEntry[] = [];
  let usesVoid = false;

  if (!responses || !Object.keys(responses).length) {
    const expression = `path.ref("Void").schema`;
    builder.line(indent(`200: ${expression},`, 2));
    entries.push({
      status: "200",
      statusLiteral: "200",
      label: "Void",
    });
    return { code: builder.toString(), entries, usesVoid: true };
  }

  const sorted = Object.keys(responses).sort();
  for (const status of sorted) {
    const responseOrRef = responses[status];
    if (!responseOrRef) continue;

    const resolved = resolveResponse(responseOrRef, doc);
    const schema = resolveSchemaFromResponse(resolved);
    const resolvedSchema = resolveSchemaExpression(schema, converter);

    builder.line(indent(`${formatStatusKey(status)}: ${resolvedSchema.expression},`, 2));
    entries.push({
      status: String(status),
      statusLiteral: formatStatusType(status),
      label: resolvedSchema.label,
    });
    usesVoid = usesVoid || resolvedSchema.usesVoid;
  }

  return { code: builder.toString(), entries, usesVoid };
}

function buildRequestBody(
  requestBody:
    | OpenAPIV3.RequestBodyObject
    | OpenAPIV3.ReferenceObject
    | OpenAPIV3_1.RequestBodyObject
    | OpenAPIV3_1.ReferenceObject
    | undefined,
  converter: SchemaConverter,
  doc: OpenApiDoc,
): SchemaExpression | null {
  if (!requestBody) return null;

  const resolved =
    "$ref" in requestBody ? resolveRequestBody(requestBody, doc) : requestBody;
  if (!resolved?.content) return null;

  const schema = selectJsonSchema(resolved.content);
  if (!schema) return null;

  return resolveSchemaExpression(schema, converter);
}

function resolveSchemaExpression(
  schema:
    | OpenAPIV3.SchemaObject
    | OpenAPIV3.ReferenceObject
    | OpenAPIV3_1.SchemaObject
    | OpenAPIV3_1.ReferenceObject
    | undefined,
  converter: SchemaConverter,
): SchemaExpression {
  if (!schema) {
    return {
      expression: `path.ref("Void").schema`,
      label: "Void",
      usesVoid: true,
    };
  }

  const refName = extractSchemaRef(schema);
  if (refName) {
    const registryKey = converter.registryKey(refName);
    const base = `path.ref(${JSON.stringify(registryKey)}).schema`;
    return {
      expression: wrapNullable(base, isNullable(schema)),
      label: registryKey,
      usesVoid: false,
    };
  }

  const arrayRefName = extractArraySchemaRef(schema);
  if (arrayRefName) {
    const registryKey = converter.registryKey(arrayRefName);
    const base = `path.ref(${JSON.stringify(registryKey)}).array()`;
    return {
      expression: wrapNullable(base, isNullable(schema)),
      label: `${registryKey}[]`,
      usesVoid: false,
    };
  }

  return {
    expression: converter.convert(schema),
    label: "InlineSchema",
    usesVoid: false,
  };
}

function buildTypeAliases(
  operations: OperationDescriptor[],
  schemaConstName: string,
): string {
  if (!operations.length) return "";

  const lines: string[] = [];
  lines.push("// Derived types");

  for (const operation of operations) {
    const pathLiteral = JSON.stringify(operation.path);
    const methodLiteral = JSON.stringify(operation.method);

    if (operation.request) {
      lines.push(
        `export type ${operation.typeName}Request = ReturnType<typeof ${schemaConstName}.$Infer.Request<${pathLiteral}, ${methodLiteral}>>;`,
      );
    }

    lines.push(
      `export type ${operation.typeName}Responses = ReturnType<typeof ${schemaConstName}.$Infer.Responses<${pathLiteral}, ${methodLiteral}>>;`,
    );

    for (const response of operation.responses) {
      const suffix = formatStatusSuffix(response.status);
      lines.push(
        `export type ${operation.typeName}Response${suffix} = ReturnType<typeof ${schemaConstName}.$Infer.Response<${pathLiteral}, ${methodLiteral}, ${response.statusLiteral}>>;`,
      );
    }

    lines.push("");
  }

  return lines.join("\n");
}

function buildOperationTypeName(
  rawPath: string,
  method: SupportedMethod,
  operationId?: string,
): string {
  if (operationId) {
    return Casing.toPascalCase(operationId);
  }

  const normalizedPath = normalizePath(rawPath);
  const segments = normalizedPath
    .split("/")
    .filter(Boolean)
    .map((segment) => (segment.startsWith(":") ? `by-${segment.slice(1)}` : segment));

  return Casing.toPascalCase([...segments, method].join("-"));
}

function ensureUniqueTypeName(
  baseName: string,
  used: Map<string, number>,
): string {
  const count = used.get(baseName) ?? 0;
  if (count === 0) {
    used.set(baseName, 1);
    return baseName;
  }

  const next = `${baseName}${count + 1}`;
  used.set(baseName, count + 1);
  return next;
}

function encodeJsonPointerPath(pathname: string): string {
  return pathname.replace(/~/g, "~0").replace(/\//g, "~1");
}

function extractSchemaRef(
  schema:
    | OpenAPIV3.SchemaObject
    | OpenAPIV3.ReferenceObject
    | OpenAPIV3_1.SchemaObject
    | OpenAPIV3_1.ReferenceObject,
): string | null {
  if (!schema || typeof schema !== "object") return null;
  if (!("$ref" in schema)) return null;
  return extractComponentSchemaName(schema.$ref);
}

function extractArraySchemaRef(
  schema:
    | OpenAPIV3.SchemaObject
    | OpenAPIV3.ReferenceObject
    | OpenAPIV3_1.SchemaObject
    | OpenAPIV3_1.ReferenceObject,
): string | null {
  if (!schema || typeof schema !== "object") return null;
  if ((schema as OpenAPIV3.SchemaObject).type !== "array") return null;
  const items = (schema as OpenAPIV3.ArraySchemaObject).items;
  if (!items || typeof items !== "object") return null;
  if (!("$ref" in items)) return null;
  return extractComponentSchemaName((items as OpenAPIV3.ReferenceObject).$ref);
}

function extractComponentSchemaName(ref: string): string | null {
  const match = ref.match(/^#\/components\/schemas\/(.+)$/);
  return match ? match[1] : null;
}

function selectJsonSchema(
  content: Record<string, OpenAPIV3.MediaTypeObject | OpenAPIV3_1.MediaTypeObject>,
): OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | OpenAPIV3_1.SchemaObject | OpenAPIV3_1.ReferenceObject | undefined {
  if (content["application/json"]?.schema) {
    return content["application/json"].schema;
  }

  const first = Object.values(content)[0];
  return first?.schema;
}

function resolveSchemaFromResponse(
  response: OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject | undefined,
): OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject | OpenAPIV3_1.SchemaObject | OpenAPIV3_1.ReferenceObject | undefined {
  if (!response?.content) {
    return undefined;
  }
  return selectJsonSchema(response.content);
}

function normalizePath(pathname: string): string {
  return pathname.replace(/{(.*?)}/g, ":$1");
}

function indent(value: string, depth: number): string {
  const pad = "  ".repeat(depth);
  return value
    .split("\n")
    .map((line) => (line ? pad + line : line))
    .join("\n");
}

function isNullable(schema: unknown): boolean {
  if (!schema || typeof schema !== "object") return false;
  return Boolean((schema as any).nullable);
}

function wrapNullable(expr: string, nullable?: boolean): string {
  return nullable ? `${expr}.nullable()` : expr;
}

function formatStatusKey(status: string): string {
  const trimmed = String(status).trim();
  const numeric = Number(trimmed);
  if (!Number.isNaN(numeric) && `${numeric}` === trimmed) {
    return trimmed;
  }
  return JSON.stringify(trimmed);
}

function formatStatusType(status: string): string {
  return formatStatusKey(status);
}

function formatStatusSuffix(status: string): string {
  const safe = String(status).replace(/[^a-zA-Z0-9]+/g, "-");
  const pascal = Casing.toPascalCase(safe);
  return pascal || "Unknown";
}

function resolveResponse(
  response: OpenAPIV3.ReferenceObject | OpenAPIV3.ResponseObject | OpenAPIV3_1.ReferenceObject | OpenAPIV3_1.ResponseObject,
  doc: OpenApiDoc,
): OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject | undefined {
  if ("$ref" in response) {
    return getComponent(doc, response.$ref, "responses");
  }
  return response;
}

function resolveRequestBody(
  requestBody: OpenAPIV3.ReferenceObject | OpenAPIV3_1.ReferenceObject,
  doc: OpenApiDoc,
): OpenAPIV3.RequestBodyObject | OpenAPIV3_1.RequestBodyObject | undefined {
  return getComponent(doc, requestBody.$ref, "requestBodies");
}

function getComponent<T>(
  doc: OpenApiDoc,
  ref: string,
  type: "responses" | "requestBodies",
): T | undefined {
  const match = ref.match(/^#\/components\/([^/]+)\/(.+)$/);
  if (!match) return undefined;
  const [, category, name] = match;
  if (category !== type) return undefined;
  const component = (doc as any).components?.[type]?.[name];
  return component as T | undefined;
}

class CodeBuilder {
  private readonly lines: string[] = [];

  line(text: string): void {
    this.lines.push(text);
  }

  toString(): string {
    return this.lines.join("\n");
  }
}
