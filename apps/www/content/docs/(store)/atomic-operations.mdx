---
title: Atomic Operations
description: Perform atomic operations on numeric values and manage key expiration. Use increment for counters and expire for TTL management.
---

## Overview

Atomic operations are fundamental for building reliable distributed systems. The Store adapter provides atomic operations that are guaranteed to execute without interference from concurrent operations, making them perfect for counters, rate limiting, and expiration management.

<Callout type="info">
  Atomic operations are essential in distributed systems where multiple processes might modify the same key simultaneously. They ensure data consistency without locks.
</Callout>

---

## Increment Operation

The `increment()` method atomically increments a numeric value stored at a key. If the key doesn't exist, it's initialized to 0 before incrementing.

### Basic Usage

```typescript
handler: async ({ context }) => {
  // Increment a counter
  const newValue = await context.store.increment('page:views');
  // If key didn't exist, newValue will be 1
  // If key existed with value 5, newValue will be 6
  
  return response.success({ views: newValue });
}
```

### Counter Patterns

#### Page Views Counter

```typescript
const trackPageView = async (pageId: string, context: AppContext) => {
  const views = await context.store.increment(`page:${pageId}:views`);
  
  // Set expiration on first view
  if (views === 1) {
    await context.store.expire(`page:${pageId}:views`, 86400); // 24 hours
 ADN  }
  
  return views;
};
```

#### User Activity Counter

```typescript
const trackUserActivity = async (userId: string, context: AppContext) => {
  const today = new Date().toISOString().split('T')[0];
  const key = `user:${userId}:activity:${today}`;
  
  const count = await context.store.increment(key);
  
  // Reset daily
  if (count === 1) {
    await context.store.expire(key, 86400); // Expires at midnight
  }
  
  return count;
};
```

#### Distributed Counter

```typescript
const incrementGlobalCounter = async (
  counterName: string,
  context: AppContext
) => {
  // Atomic increment across all instances
  const value = await context.store.increment(`counter:${counterName}`);
  
  return value;
};

// Multiple instances can safely call this simultaneously
await incrementGlobalCounter('total-requests', context);
```

---

## Expire Operation

The `expire()` method sets or updates the time-to-live (TTL) of a key. This is useful for managing cache expiration and cleaning up temporary data.

### Basic Usage

```typescript
handler: async ({ context }) => {
  // Set TTL on an existing key
  await context.store.set('user:123', userData);
  await context.store.expire('user:123', 3600); // Expires in 1 hour
  
  // Update expiration
  await context.store.expire('user:123', 7200); // Extend to 2 hours
  
  return response.success({ message: 'TTL set' });
}
```

### Expiration Patterns

#### Auto-Expiring Sessions

```typescript
const createSession = async (userId: string, context: AppContext) => {
  const sessionId = generateSessionId();
  const sessionData = {
    userId,
    createdAt: new Date().toISOString(),
  };
  
  // Store session
  await context.store.set(`session:${sessionId}`, sessionData);
  
  // Auto-expire after 24 hours
  await context.store.expire(`session:${sessionId}`, 86400);
  
  return sessionId;
};

const refreshSession = async (sessionId: string, context: AppContext) => {
  const session = await context.store.get<SessionData>(`session:${sessionId}`);
  
  if (session) {
    // Refresh expiration
    await context.store.expire(`session:${sessionId}`, 86400);
    return session;
  }
  
  return null;
};
```

#### Temporary Data Cleanup

```typescript
const storeTemporaryData = async (
  key: string,
  data: any,
  ttl: number,
  context: AppContext
) => {
  await context.store.set(key, data);
  await context.store.expire(key, ttl);
  
  // Data will automatically expire after TTL
};
```

#### Refresh Expiration on Access

```typescript
const getWithRefresh = async <T>(
  key: string,
  ttl: number,
  context: AppContext
): Promise<T | null> => {
  const value = await context.store.get<T>(key);
  
  if (value) {
    // Refresh expiration when accessed
    await context.store.expire(key, ttl);
  }
  
  return value;
};
```

---

## Combined Operations

### Rate Limiting

Implement rate limiting using atomic increment and expiration:

```typescript
const checkRateLimit = async (
  identifier: string,
  limit: number,
  windowSeconds: number,
  context: AppContext
): Promise<{ allowed: boolean; remaining: number }> => {
  const key = `rate:limit:${identifier}`;
  
  // Increment counter
  const count = await context.store.increment(key);
  
  // Set expiration on first request
  if (count === 1) {
    await context.store.expire(key, windowSeconds);
  }
  
  // Check if limit exceeded
  if (count > limit) {
    return {
      allowed: false,
      remaining: 0,
    };
  }
  
  return {
    allowed: true,
    remaining: limit - count,
  };
};

// Usage
const rateLimitMiddleware = async (request: Request, context: AppContext) => {
  const { allowed, remaining } = await checkRateLimit(
    request.ip,
    100, // 100 requests
    60,   // per 60 seconds
    context
  );
  
  if (!allowed) {
    throw new Error('Rate limit exceeded');
  }
  
  // Set rate limit headers
  response.headers.set('X-RateLimit-Remaining', remaining.toString());
};
```

### Sliding Window Rate Limiting

More sophisticated rate limiting with sliding windows:

```typescript
const slidingWindowRateLimit = async (
  identifier: string,
  limit: number,
  windowSeconds: number,
  context: AppContext
): Promise<{ allowed: boolean; remaining: number; resetAt: Date }> => {
  const now = Date.now();
  const windowStart = Math.floor(now / (windowSeconds * 1000));
  const key = `rate:sliding:${identifier}:${windowStart}`;
  
  const count = await context.store.increment(key);
  
  // Set expiration
  if (count === 1) {
    await context.store.expire(key, windowSeconds * 2); // Keep 2 windows
  }
  
  // Check all windows in current period
  const currentWindow = windowStart;
  const previousWindow = currentWindow - 1;
  
  const [currentCount, previousCount] = await Promise.all([
    context.store.get<number>(`rate:sliding:${identifier}:${currentWindow}`) || 0,
    context.store.get<number>(`rate:sliding:${identifier}:${previousWindow}`) || 0,
  ]);
  
  // Calculate weighted count (prorate previous window)
  const weight = (now % (windowSeconds * 1000)) / (windowSeconds * 1000);
  const totalCount = currentCount + previousCount * (1 - weight);
  
  if (totalCount >= limit) {
    return {
      allowed: false,
      remaining: 0,
      resetAt: new Date((currentWindow + 1) * windowSeconds * 1000),
    };
  }
  
  return {
    allowed: true,
    remaining: Math.floor(limit - totalCount),
    resetAt: new Date((currentWindow + 1) * windowSeconds * 1000),
  };
};
```

### Distributed Locks

Implement distributed locks using increment and expiration:

```typescript
const acquireLock = async (
  lockName: string,
  ttl: number,
  context: AppContext
): Promise<{ acquired: boolean; lockId?: string }> => {
  const lockId = generateLockId();
  const key = `lock:${lockName}`;
  
  // Try to set lock (only if doesn't exist)
  const exists = await context.store.has(key);
  if (exists) {
    return { acquired: false };
  }
  
  // Set lock with expiration
  await context.store.set(key, lockId);
  await context.store.expire(key, ttl);
  
  return { acquired: true, lockId };
};

const releaseLock = async (
  lockName: string,
  lockId: string,
  context: AppContext
): Promise<boolean> => {
  const key = `lock:${lockName}`;
  const storedLockId = await context.store.get<string>(key);
  
  if (storedLockId === lockId) {
    await context.store.delete(key);
    return true;
  }
  
  return false;
};

// Usage
const performWithLock = async (
  taskName: string,
  task: () => Promise<void>,
  context: AppContext
) => {
  const { acquired, lockId } = await acquireLock(taskName, 60, context);
  
  if (!acquired) {
    throw new Error('Could not acquire lock');
  }
  
  try {
    await task();
  } finally {
    if (lockId) {
      await releaseLock(taskName, lockId, context);
    }
  }
};
```

### Request Counting

Track requests with automatic expiration:

```typescript
const trackRequest = async (
  endpoint: string,
  context: AppContext
): Promise<number> => {
  const today = new Date().toISOString().split('T')[0];
  const key = `requests:${endpoint}:${today}`;
  
  const count = await context.store.increment(key);
  
  // Set expiration to end of day
  if (count === 1) {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    const secondsUntilMidnight = Math.floor(
      (tomorrow.getTime() - Date.now()) / 1000
    );
    await context.store.expire(key, secondsUntilMidnight);
  }
  
  return count;
};
```

---

## Best Practices

### 1. Initialize Counters Properly

```typescript
// ✅ Good: Let increment initialize to 0
const count = await context.store.increment('counter');
// First call returns 1

// ❌ Bad: Manual initialization (race condition)
if (!(await context.store.has('counter'))) {
  await context.store.set('counter', 0);
}
const count = await context.store.increment('counter');
```

### 2. Set Expiration on First Increment

```typescript
// ✅ Good: Set expiration on first increment
const count = await context.store.increment('counter');
if (count === 1) {
  await context.store.expire('counter', 3600);
}

// ❌ Bad: May forget to set expiration
const count = await context.store.increment('counter');
// Missing expiration = counter never expires
```

### 3. Use Appropriate TTL Values

```typescript
// ✅ Good: TTL matches use case
await context.store.expire('session:123', 86400); // 24 hours for sessions
await context.store.expire('rate:limit:ip', 60);  // 1 minute for rate limits
await context.store.expire('cache:data', 3600);   // 1 hour for cache

// ❌ Bad: Inappropriate TTL
await context.store.expire('session:123', 31536000); // 1 year for session (too long)
await context.store.expire('rate:limit:ip', 86400);  // 1 day for rate limit (too long)
```

### 4. Handle Race Conditions

```typescript
// ✅ Good: Atomic operations prevent race conditions
const count = await context.store.increment('counter');
// Safe even with concurrent requests

// ❌ Bad: Non-atomic operations
const current = await context.store.get<number>('counter') || 0;
await context.store.set('counter', current + 1);
// Race condition: two requests might both read same value
```

---

## Error Handling

Handle errors gracefully:

```typescript
const safeIncrement = async (
  key: string,
  context: AppContext
): Promise<number | null> => {
  try {
    return await context.store.increment(key);
  } catch (error) {
    context.logger.error('Failed to increment counter', { error, key });
    return null;
  }
};

const safeExpire = async (
  key: string,
  ttl: number,
  context: AppContext
): Promise<boolean> => {
  try {
    await context.store.expire(key, ttl);
    return true;
  } catch (error) {
    context.logger.error('Failed to set expiration', { error, key, ttl });
    return false;
  }
};
```

---

## Performance Considerations

### Batch Operations

When possible, batch operations:

```typescript
// ✅ Good: Single increment
const count = await context.store.increment('counter');

// ❌ Bad: Multiple operations (if increment + expire can be combined)
await context.store.increment('counter');
await context.store.expire('counter', 3600);
```

### Monitoring Atomic Operations

High-frequency atomic operations can be monitored:

```typescript
const incrementWithMetrics = async (
  key: string,
  context: AppContext
): Promise<number> => {
  const start = Date.now();
  const value = await context.store.increment(key);
  const duration = Date.now() - start;
  
  // Log metrics
  context.logger.debug('Increment operation', {
    key,
    value,
    duration,
  });
  
  return value;
};
```

---

## Real-World Examples

### API Usage Tracking

```typescript
const trackApiUsage = async (
  apiKey: string,
  endpoint: string,
  context: AppContext
) => {
  const month = new Date().toISOString().slice(0, 7); // YYYY-MM
  const key = `api:usage:${apiKey}:${month}`;
  
  const count = await context.store.increment(key);
  
  // Set expiration to end of month
  if (count === 1) {
    const nextMonth = new Date();
    nextMonth.setMonth(nextMonth.getMonth() + 1);
    nextMonth.setDate(1);
    nextMonth.setHours(0, 0, 0, 0);
    const secondsUntilNextMonth = Math.floor(
      (nextMonth.getTime() - Date.now()) / 1000
    );
    await context.store.expire(key, secondsUntilNextMonth);
  }
  
  return count;
};
```

### Feature Flags with Usage Limits

```typescript
const checkFeatureUsage = async (
  userId: string,
  featureName: string,
  limit: number,
  context: AppContext
): Promise<{ allowed: boolean; usage: number }> => {
  const key = `feature:usage:${userId}:${featureName}`;
  const usage = await context.store.increment(key);
  
  // Set daily expiration
  if (usage === 1) {
    await context.store.expire(key, 86400);
  }
  
  return {
    allowed: usage <= limit,
    usage,
  };
};
```

---

## Next Steps

- Learn about [caching operations](/docs/store/caching) for storing data
- Explore [Pub/Sub messaging](/docs/store/pubsub) for event-driven communication
- Check out [advanced usage patterns](/docs/store/advanced)

