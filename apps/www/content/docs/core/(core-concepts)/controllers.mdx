---
title: Controllers
description: Learn how to organize actions into logical controllers with shared paths, group related endpoints, and build modular APIs with Igniter.js.
---

## Overview

**Controllers** group related actions together under a common path prefix. They help you organize your API into logical modules, making it easier to maintain and understand.

```typescript
import { igniter } from '@/igniter';

const userController = igniter.controller({
  name: 'Users',
  description: 'Manage user accounts and profiles',
  path: '/users',
  actions: {
    list: igniter.query({ name: 'List Users', path: '/', handler: ... }),
    getById: igniter.query({ name: 'Get User', path: '/:id' as const, handler: ... }),
    create: igniter.mutation({ name: 'Create User', path: '/', method: 'POST', handler: ... }),
    update: igniter.mutation({ name: 'Update User', path: '/:id' as const, method: 'PUT', handler: ... }),
    delete: igniter.mutation({ name: 'Delete User', path: '/:id' as const, method: 'DELETE', handler: ... })
  }
});
```

<Callout type="info" title="What is a Controller?">
  A controller is a collection of **related actions** that share a common **path prefix**. All actions inside a controller automatically inherit the controller's path.
</Callout>

---

## Creating a Controller

### Basic Controller

```typescript
import { igniter } from '@/igniter';

const userController = igniter.controller({
  name: 'Users',
  description: 'Manage user accounts and profiles',
  path: '/users',
  actions: {
    list: igniter.query({
      name: 'List Users',
      description: 'Retrieve all users',
      path: '/',
      handler: async ({ context, response }) => {
        const users = await context.db.users.findMany();
        return response.success({ users });
      }
    })
  }
});

// Creates endpoint: GET /users/
```

### Controller with Multiple Actions

```typescript
import { igniter } from '@/igniter';
import { z } from 'zod';

const CreateUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email()
});

const UpdateUserSchema = CreateUserSchema.partial();

const userController = igniter.controller({
  name: 'Users',
  description: 'Manage user accounts and profiles',
  path: '/users',
  actions: {
    // GET /users/
    list: igniter.query({
      name: 'List Users',
      description: 'Retrieve all users',
      path: '/',
      handler: async ({ context, response }) => {
        const users = await context.db.users.findMany();
        return response.success({ users });
      }
    }),

    // GET /users/:id
    getById: igniter.query({
      name: 'Get User by ID',
      description: 'Retrieve a specific user by their ID',
      path: '/:id' as const,
      handler: async ({ request, context, response }) => {
        const user = await context.db.users.findUnique({
          where: { id: request.params.id }
        });
        
        if (!user) {
          return response.notFound({ message: 'User not found' });
        }
        
        return response.success({ user });
      }
    }),
    
    // POST /users/
    create: igniter.mutation({
      name: 'Create User',
      description: 'Create a new user account',
      path: '/',
      method: 'POST',
      body: CreateUserSchema,
      handler: async ({ request, context, response }) => {
        const user = await context.db.users.create({
          data: request.body
        });
        return response.created({ user });
      }
    }),

    // PUT /users/:id
    update: igniter.mutation({
      name: 'Update User',
      description: 'Update an existing user by ID',
      path: '/:id' as const,
      method: 'PUT',
      body: UpdateUserSchema,
      handler: async ({ request, context, response }) => {
        const user = await context.db.users.update({
          where: { id: request.params.id },
          data: request.body
        });
        return response.success({ user });
      }
    }),

    // DELETE /users/:id
    delete: igniter.mutation({
      name: 'Delete User',
      description: 'Delete a user by ID',
      path: '/:id' as const,
      method: 'DELETE',
      handler: async ({ request, context, response }) => {
        await context.db.users.delete({
          where: { id: request.params.id }
        });
        return response.success({ message: 'User deleted' });
      }
    })
  }
});
```

---

## Controller Configuration

### Path Prefix

The `path` property sets the base path for all actions in the controller:

```typescript
const postController = igniter.controller({
  name: 'Posts',
  description: 'Manage blog posts and articles',
  path: '/posts',  // ← Base path
  actions: {
    list: igniter.query({ name: 'List Posts', path: '/', ... }),        // → GET /posts/
    getById: igniter.query({ name: 'Get Post', path: '/:id' as const, ... }),  // → GET /posts/:id
    create: igniter.mutation({ name: 'Create Post', path: '/', ... })    // → POST /posts/
  }
});
```

<Callout type="success" title="Automatic Path Combination">
  Controller path (`/posts`) + Action path (`/:id`) = Full route (`/posts/:id`)
</Callout>

### Name and Description

Add metadata for documentation and OpenAPI generation:

```typescript
const userController = igniter.controller({
  name: 'Users',
  path: '/users',
  description: 'User management endpoints for authentication and profile data',
  actions: {
    // ...
  }
});
```

<Callout type="success" title="OpenAPI Documentation">
  The `name` and `description` properties are crucial for generating comprehensive OpenAPI specifications. They enable the CLI to create detailed documentation that powers **Igniter Studio** (our interactive API playground), making your API much more discoverable and user-friendly.
</Callout>

<TypeTable type={{
  name: {
    type: 'string',
    description: 'Display name for documentation',
    required: false
  },
  path: {
    type: 'string',
    description: 'Base path prefix for all actions (e.g., "/users")',
    required: true
  },
  description: {
    type: 'string',
    description: 'Controller description for documentation',
    required: false
  },
  actions: {
    type: 'Record<string, IgniterAction>',
    description: 'Map of action name to action configuration',
    required: true
  }
}} />

---

## Organizing Controllers

### Feature-Based Organization

Group controllers by feature or domain:

<Files>
  <Folder name="src" defaultOpen>
    <Folder name="features" defaultOpen>
      <Folder name="users">
        <File name="user.controller.ts" />
        <File name="user.service.ts" />
        <File name="user.schema.ts" />
      </Folder>
      <Folder name="posts">
        <File name="post.controller.ts" />
        <File name="post.service.ts" />
        <File name="post.schema.ts" />
      </Folder>
      <Folder name="comments">
        <File name="comment.controller.ts" />
        <File name="comment.service.ts" />
        <File name="comment.schema.ts" />
      </Folder>
    </Folder>
    <File name="igniter.ts" />
    <File name="igniter.router.ts" />
  </Folder>
</Files>

```typescript
// features/users/user.controller.ts
export const userController = igniter.controller({
  name: 'Users',
  description: 'Manage user accounts and profiles',
  path: '/users',
  actions: { /* ... */ }
});

// features/posts/post.controller.ts
export const postController = igniter.controller({
  name: 'Posts',
  description: 'Manage blog posts and articles',
  path: '/posts',
  actions: { /* ... */ }
});

// igniter.router.ts
import { userController } from '@/features/users/user.controller';
import { postController } from '@/features/posts/post.controller';

export const AppRouter = igniter.router({
  controllers: {
    users: userController,
    posts: postController
  }
});
```

### Nested Paths

Create hierarchical APIs with nested paths:

```typescript
const postCommentController = igniter.controller({
  name: 'Post Comments',
  description: 'Manage comments on blog posts',
  path: '/posts/:postId/comments' as const,
  actions: {
    // GET /posts/:postId/comments/
    list: igniter.query({
      name: 'List Post Comments',
      description: 'Get all comments for a specific post',
      path: '/',
      handler: async ({ request, context, response }) => {
        const comments = await context.db.comments.findMany({
          where: { postId: request.params.postId }
        });
        return response.success({ comments });
      }
    }),

    // POST /posts/:postId/comments/
    create: igniter.mutation({
      name: 'Create Comment',
      description: 'Add a new comment to a post',
      path: '/',
      method: 'POST',
      body: CreateCommentSchema,
      handler: async ({ request, context, response }) => {
        const comment = await context.db.comments.create({
          data: {
            ...request.body,
            postId: request.params.postId
          }
        });
        return response.created({ comment });
      }
    }),
    
    // GET /posts/:postId/comments/:id
    getById: igniter.query({
      name: 'Get Comment',
      description: 'Retrieve a specific comment by ID',
      path: '/:id' as const,
      handler: async ({ request, context, response }) => {
        const comment = await context.db.comments.findUnique({
          where: { 
            id: request.params.id,
            postId: request.params.postId 
          }
        });
        
        if (!comment) {
          return response.notFound({ message: 'Comment not found' });
        }
        
        return response.success({ comment });
      }
    })
  }
});
```

---

## Common Patterns

### CRUD Controller

A complete CRUD (Create, Read, Update, Delete) controller:

```typescript
import { igniter } from '@/igniter';
import { z } from 'zod';

const CreateSchema = z.object({
  name: z.string(),
  description: z.string()
});

const UpdateSchema = CreateSchema.partial();

function createCrudController<T extends string>(resource: T) {
  const capitalizedResource = resource.charAt(0).toUpperCase() + resource.slice(1);

  return igniter.controller({
    name: `${capitalizedResource}`,
    description: `Manage ${resource} resources`,
    path: `/${resource}`,
    actions: {
      // List all
      list: igniter.query({
        name: `List ${capitalizedResource}`,
        description: `Retrieve all ${resource}`,
        path: '/',
        handler: async ({ context, response }) => {
          const items = await context.db[resource].findMany();
          return response.success({ [resource]: items });
        }
      }),

      // Get one by ID
      getById: igniter.query({
        name: `Get ${capitalizedResource}`,
        description: `Retrieve a specific ${resource} by ID`,
        path: '/:id' as const,
        handler: async ({ request, context, response }) => {
          const item = await context.db[resource].findUnique({
            where: { id: request.params.id }
          });
          
          if (!item) {
            return response.notFound({ message: `${resource} not found` });
          }
          
          return response.success({ [resource]: item });
        }
      }),
      
      // Create new
      create: igniter.mutation({
        name: `Create ${capitalizedResource}`,
        description: `Create a new ${resource}`,
        path: '/',
        method: 'POST',
        body: CreateSchema,
        handler: async ({ request, context, response }) => {
          const item = await context.db[resource].create({
            data: request.body
          });
          return response.created({ [resource]: item });
        }
      }),

      // Update existing
      update: igniter.mutation({
        name: `Update ${capitalizedResource}`,
        description: `Update an existing ${resource} by ID`,
        path: '/:id' as const,
        method: 'PUT',
        body: UpdateSchema,
        handler: async ({ request, context, response }) => {
          const item = await context.db[resource].update({
            where: { id: request.params.id },
            data: request.body
          });
          return response.success({ [resource]: item });
        }
      }),

      // Delete
      delete: igniter.mutation({
        name: `Delete ${capitalizedResource}`,
        description: `Delete a ${resource} by ID`,
        path: '/:id' as const,
        method: 'DELETE',
        handler: async ({ request, context, response }) => {
          await context.db[resource].delete({
            where: { id: request.params.id }
          });
          return response.success({ message: `${resource} deleted` });
        }
      })
    }
  });
}

// Usage
const productController = createCrudController('products');
const categoryController = createCrudController('categories');
```

### Search & Filter Controller

```typescript
const SearchSchema = z.object({
  q: z.string().min(1),
  category: z.string().optional(),
  minPrice: z.coerce.number().optional(),
  maxPrice: z.coerce.number().optional(),
  sortBy: z.enum(['price', 'date', 'name']).default('date'),
  order: z.enum(['asc', 'desc']).default('desc'),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20)
});

const productController = igniter.controller({
  name: 'Products',
  description: 'Manage product catalog with search and filtering',
  path: '/products',
  actions: {
    search: igniter.query({
      name: 'Search Products',
      description: 'Search and filter products with pagination',
      path: '/search',
      query: SearchSchema,
      handler: async ({ request, context, response }) => {
        const { q, category, minPrice, maxPrice, sortBy, order, page, limit } = request.query;
        const skip = (page - 1) * limit;
        
        const [products, total] = await Promise.all([
          context.db.products.findMany({
            where: {
              name: { contains: q, mode: 'insensitive' },
              category: category,
              price: {
                gte: minPrice,
                lte: maxPrice
              }
            },
            orderBy: { [sortBy]: order },
            skip,
            take: limit
          }),
          context.db.products.count({
            where: {
              name: { contains: q, mode: 'insensitive' },
              category: category
            }
          })
        ]);
        
        return response.success({
          products,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit)
          }
        });
      }
    })
  }
});
```

### Protected Controller

Apply authentication to all actions in a controller:

```typescript
const authProcedure = igniter.procedure({
  handler: async ({ context, request }) => {
    const token = request.headers.get('authorization')?.replace('Bearer ', '');
    
    if (!token) {
      throw new Error('Authentication required');
    }
    
    const user = await verifyToken(token);
    
    return {
      currentUser: user
    };
  }
});

const protectedController = igniter.controller({
  name: 'Protected',
  description: 'Protected endpoints requiring authentication',
  path: '/protected',
  actions: {
    getData: igniter.query({
      name: 'Get Protected Data',
      description: 'Retrieve user-specific protected data',
      path: '/data',
      use: [authProcedure],
      handler: async ({ context, response }) => {
        return response.success({
          message: `Hello, ${context.currentUser.name}`
        });
      }
    }),

    getSettings: igniter.query({
      name: 'Get User Settings',
      description: 'Retrieve user settings and preferences',
      path: '/settings',
      use: [authProcedure],
      handler: async ({ context, response }) => {
        const settings = await context.db.settings.findUnique({
          where: { userId: context.currentUser.id }
        });
        return response.success({ settings });
      }
    })
  }
});
```

---

## Versioned Controllers

Create multiple versions of the same controller:

```typescript
// v1/user.controller.ts
export const userControllerV1 = igniter.controller({
  name: 'Users API v1',
  description: 'Legacy user management API',
  path: '/v1/users',
  actions: {
    list: igniter.query({
      name: 'List Users v1',
      description: 'Retrieve users (legacy format)',
      path: '/',
      handler: async ({ context, response }) => {
        // Old implementation
        const users = await context.db.users.findMany({
          select: { id: true, name: true, email: true }
        });
        return response.success({ users });
      }
    })
  }
});

// v2/user.controller.ts
export const userControllerV2 = igniter.controller({
  name: 'Users API v2',
  description: 'Enhanced user management API',
  path: '/v2/users',
  actions: {
    list: igniter.query({
      name: 'List Users v2',
      description: 'Retrieve users with extended information',
      path: '/',
      handler: async ({ context, response }) => {
        // New implementation with additional fields
        const users = await context.db.users.findMany({
          select: {
            id: true,
            name: true,
            email: true,
            avatar: true,        // ← New field
            createdAt: true,     // ← New field
            role: true           // ← New field
          }
        });
        return response.success({ users });
      }
    })
  }
});

// Router
export const AppRouter = igniter.router({
  controllers: {
    usersV1: userControllerV1,  // /v1/users
    usersV2: userControllerV2   // /v2/users
  }
});
```

---

## Best Practices

### 1. Group by Domain

Organize controllers by business domain, not technical layers:

```typescript
// ✅ Good - Domain-based
const userController = igniter.controller({ path: '/users', ... });
const postController = igniter.controller({ path: '/posts', ... });
const commentController = igniter.controller({ path: '/comments', ... });

// ❌ Bad - Layer-based
const readController = igniter.controller({ path: '/read', ... });
const writeController = igniter.controller({ path: '/write', ... });
```

### 2. Keep Controllers Focused

Each controller should handle one resource or feature:

```typescript
// ✅ Good - Single responsibility
const userController = igniter.controller({
  path: '/users',
  actions: {
    list: ...,
    getById: ...,
    create: ...,
    update: ...,
    delete: ...
  }
});

// ❌ Bad - Mixed responsibilities
const apiController = igniter.controller({
  path: '/api',
  actions: {
    getUsers: ...,
    getPosts: ...,
    getComments: ...,
    createUser: ...,
    createPost: ...
  }
});
```

### 3. Use Consistent Naming

Follow RESTful conventions for action names:

```typescript
const resourceController = igniter.controller({
  name: 'Resources',
  description: 'Generic resource management',
  path: '/resources',
  actions: {
    list: igniter.query({
      name: 'List Resources',
      description: 'Retrieve all resources',
      path: '/', ...
    }),           // GET /resources
    getById: igniter.query({
      name: 'Get Resource',
      description: 'Retrieve a specific resource by ID',
      path: '/:id' as const, ...
    }),     // GET /resources/:id
    create: igniter.mutation({
      name: 'Create Resource',
      description: 'Create a new resource',
      method: 'POST', ...
    }), // POST /resources
    update: igniter.mutation({
      name: 'Update Resource',
      description: 'Update an existing resource',
      method: 'PUT', ...
    }),  // PUT /resources/:id
    delete: igniter.mutation({
      name: 'Delete Resource',
      description: 'Delete a resource by ID',
      method: 'DELETE', ...
    }) // DELETE /resources/:id
  }
});
```

### 4. Extract Shared Logic

Use procedures for shared validation or authorization:

```typescript
const adminOnlyProcedure = igniter.procedure({
  handler: async ({ context }) => {
    if (!context.user?.isAdmin) {
      throw new Error('Admin access required');
    }
    return {};
  }
});

const adminController = igniter.controller({
  path: '/admin',
  actions: {
    getUsers: igniter.query({
      use: [adminOnlyProcedure],
      handler: ...
    }),
    deleteUser: igniter.mutation({
      use: [adminOnlyProcedure],
      handler: ...
    })
  }
});
```

---

## Testing Controllers

### Unit Tests

Test individual actions:

```typescript
import { describe, it, expect } from 'vitest';
import { AppRouter } from '@/igniter.router';

describe('User Controller', () => {
  it('should list all users', async () => {
    const result = await AppRouter.caller.users.list.query();
    
    expect(result.data.users).toBeInstanceOf(Array);
  });

  it('should get user by ID', async () => {
    const result = await AppRouter.caller.users.getById.query({ id: '1' });
    
    expect(result.data.user).toBeDefined();
    expect(result.data.user.id).toBe('1');
  });

  it('should create a user', async () => {
    const result = await AppRouter.caller.users.create.mutate({
      body: {
        name: 'Test User',
        email: 'test@example.com'
      }
    });
    
    expect(result.data.user.name).toBe('Test User');
  });
});
```

### Integration Tests

Test full request flow:

```typescript
import { describe, it, expect } from 'vitest';

describe('User API Integration', () => {
  it('should handle user lifecycle', async () => {
    // Create
    const created = await AppRouter.caller.users.create.mutate({
      body: { name: 'John', email: 'john@example.com' }
    });
    const userId = created.data.user.id;
    
    // Read
    const read = await AppRouter.caller.users.getById.query({ id: userId });
    expect(read.data.user.name).toBe('John');
    
    // Update
    const updated = await AppRouter.caller.users.update.mutate({
      params: { id: userId },
      body: { name: 'Jane' }
    });
    expect(updated.data.user.name).toBe('Jane');
    
    // Delete
    await AppRouter.caller.users.delete.mutate({ params: { id: userId } });
    
    // Verify deletion
    await expect(
      AppRouter.caller.users.getById.query({ id: userId })
    ).rejects.toThrow();
  });
});
```

---

## Maintaining Controllers

### Schema Generation After Changes

<Callout type="error">
  **Critical:** You MUST run schema generation BEFORE using the client in your frontend. The client depends on the generated schema to function correctly.
</Callout>

<Callout type="info">
  Run this command whenever you add, modify, or remove controllers. This is required before using the client in your frontend.
</Callout>

When you add a new controller or modify existing ones, regenerate the client schema:

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']} groupId="controllers-maintenance">
  <Tab value="npm">
    ```bash
    npx @igniter-js/cli@latest generate schema
    ```
  </Tab>
  <Tab value="pnpm">
    ```bash
    pnpm dlx @igniter-js/cli@latest generate schema
    ```
  </Tab>
  <Tab value="yarn">
    ```bash
    yarn dlx @igniter-js/cli@latest generate schema
    ```
  </Tab>
  <Tab value="bun">
    ```bash
    bunx @igniter-js/cli@latest generate schema
    ```
  </Tab>
</Tabs>

This updates:
- `src/igniter.schema.ts` - Type definitions for your client
- `src/docs/openapi.json` - OpenAPI specification

---

## Next Steps

<Cards>
  <Card title="Actions" href="/docs/actions">
    Deep dive into queries and mutations
  </Card>
  
  <Card title="Procedures" href="/docs/procedures">
    Add middleware to your actions
  </Card>
  
  <Card title="Validation" href="/docs/validation">
    Master schema validation
  </Card>
  
  <Card title="Router" href="/docs/router">
    Assemble controllers into a router
  </Card>
</Cards>
