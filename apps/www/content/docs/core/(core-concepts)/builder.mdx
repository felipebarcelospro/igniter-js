---
title: Builder
description: Learn how to configure and initialize your Igniter.js application using the powerful builder pattern with full type safety and IntelliSense.
---

## Overview

The **Igniter Builder** is the foundation of your application. It provides a fluent, chainable API for configuring context, adapters, middleware, and creating fully typed API components.

```typescript
import { Igniter } from '@igniter-js/core';

const igniter = Igniter
  .context<AppContext>()
  .config({ baseURL: 'https://api.example.com' })
  .store(redisAdapter)
  .jobs(bullmqAdapter)
  .create();
```

<Callout type="info" title="Immutable Pattern">
  The builder uses an **immutable chaining pattern**. Each method returns a new instance with updated configuration, ensuring type safety throughout the entire chain.
</Callout>

---

## Core Concepts

### The Builder Pattern

Igniter.js uses the builder pattern to provide:

- ✅ **Progressive Type Enhancement** - Types become more specific as you configure
- ✅ **IntelliSense at Every Step** - Full autocomplete for all methods
- ✅ **Compile-Time Validation** - TypeScript catches configuration errors early
- ✅ **Flexible Configuration** - Add only what your application needs

### Configuration Flow

<Mermaid
  chart="
graph LR
    A[Igniter] --> B[.context<T>]
    B --> C[.config]
    C --> D[.store]
    D --> E[.jobs]
    E --> F[.telemetry]
    F --> G[.plugins]
    G --> H[.create]
    H --> I[Fully Typed API]
"
/>

---

## Builder Methods

### `.context<TContext>()`

Defines the **application-wide context type** that will be available in all actions, procedures, and middleware.

#### Static Context

Use a static object when your context doesn't depend on the request:

```typescript
interface AppContext {
  db: Database;
  config: AppConfig;
  services: {
    email: EmailService;
    storage: StorageService;
  };
}

const igniter = Igniter
  .context<AppContext>()
  .create();
```

#### Dynamic Context (Callback)

Use a callback function when context depends on the incoming request:

```typescript
type ContextCallback = (req: Request) => Promise<AppContext> | AppContext;

const igniter = Igniter
  .context(async (req: Request) => {
    const session = await getSession(req);
    const user = session ? await db.users.findById(session.userId) : null;
    
    return {
      db,
      user,
      session,
      requestId: crypto.randomUUID(),
      ip: req.headers.get('x-forwarded-for') || 'unknown'
    };
  })
  .create();
```

<Callout type="success" title="Type Inference">
  When using a callback, TypeScript automatically infers the context type from the return value. No manual type annotations needed!
</Callout>

#### Accessing Context in Actions

```typescript
const userController = igniter.controller({
  path: '/users',
  actions: {
    me: igniter.query({
      path: '/me',
      handler: async ({ context, response }) => {
        // ✅ context.user is fully typed
        if (!context.user) {
          return response.unauthorized({ message: 'Not authenticated' });
        }
        
        return response.success({ user: context.user });
      }
    })
  }
});
```

---

### `.config()`

Configures **router-level settings** like base URL and path prefix.

```typescript
const igniter = Igniter
  .context<AppContext>()
  .config({
    baseURL: 'https://api.example.com',
    basePATH: '/api/v1'
  })
  .create();
```

#### Configuration Options

<TypeTable type={{
  baseURL: {
    type: 'string',
    description: 'The base URL for your API (used by client)',
    required: false
  },
  basePATH: {
    type: 'string',
    description: 'Path prefix for all routes (e.g., "/api/v1")',
    required: false
  }
}} />

#### Usage Example

```typescript
// With this config:
.config({
  baseURL: 'https://api.example.com',
  basePATH: '/api/v1'
})

// A controller with path '/users'
igniter.controller({ path: '/users', ... })

// Creates routes at:
// https://api.example.com/api/v1/users
```

---

### `.store(adapter)`

Configures a **store adapter** for caching, key-value storage, and pub/sub messaging.

```typescript
import { createRedisStoreAdapter } from '@igniter-js/adapter-redis';

const redisStore = createRedisStoreAdapter({
  host: 'localhost',
  port: 6379,
  password: process.env.REDIS_PASSWORD
});

const igniter = Igniter
  .context<AppContext>()
  .store(redisStore)
  .create();
```

#### Using the Store

```typescript
const userController = igniter.controller({
  actions: {
    getCached: igniter.query({
      handler: async ({ context, response }) => {
        // ✅ Store is automatically available
        const cached = await igniter.store.get('users:list');
        
        if (cached) {
          return response.success({ users: JSON.parse(cached) });
        }
        
        const users = await context.db.users.findMany();
        await igniter.store.set('users:list', JSON.stringify(users), { ttl: 300 });
        
        return response.success({ users });
      }
    })
  }
});
```

<Callout type="info">
  Adding a store adapter also **automatically enables real-time capabilities** via the `.realtime` service.
</Callout>

---

### `.logger(adapter)`

Configures a **logger adapter** for structured logging.

```typescript
import { createConsoleLogger } from '@igniter-js/logger-console';

const logger = createConsoleLogger({
  level: 'info',
  colorize: true,
  context: { 
    service: 'api', 
    version: '1.0.0' 
  }
});

const igniter = Igniter
  .context<AppContext>()
  .logger(logger)
  .create();
```

#### Using the Logger

```typescript
const userController = igniter.controller({
  actions: {
    create: igniter.mutation({
      handler: async ({ request, response }) => {
        igniter.logger.info('Creating user', { 
          email: request.body.email 
        });
        
        try {
          const user = await db.users.create(request.body);
          igniter.logger.info('User created', { userId: user.id });
          return response.created({ user });
        } catch (error) {
          igniter.logger.error('Failed to create user', { error });
          return response.error({ message: 'Creation failed' });
        }
      }
    })
  }
});
```

---

### `.jobs(adapter)`

Configures a **job queue adapter** for background processing and scheduled tasks.

```typescript
import { createBullMQAdapter } from '@igniter-js/adapter-bullmq';

const jobsAdapter = createBullMQAdapter({
  store: redisStore,
  defaultJobOptions: {
    removeOnComplete: 10,
    removeOnFail: 50,
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000
    }
  }
});

const igniter = Igniter
  .context<AppContext>()
  .store(redisStore)
  .jobs(jobsAdapter)
  .create();
```

#### Defining Jobs

```typescript
// Define your jobs with full type safety
const jobs = jobsAdapter.create({
  sendEmail: {
    handler: async (payload: { to: string; subject: string; body: string }) => {
      await emailService.send(payload);
    }
  },
  processOrder: {
    handler: async (payload: { orderId: string }) => {
      const order = await db.orders.findById(payload.orderId);
      await processOrderLogic(order);
    }
  }
});
```

#### Using Jobs in Actions

```typescript
const orderController = igniter.controller({
  actions: {
    create: igniter.mutation({
      handler: async ({ request, response }) => {
        const order = await db.orders.create(request.body);
        
        // ✅ Queue a background job
        await igniter.jobs.processOrder.add({ orderId: order.id });
        
        return response.created({ order });
      }
    })
  }
});
```

---

### `.telemetry(provider)`

Configures a **telemetry provider** for distributed tracing, metrics, and observability.

```typescript
import { createOpenTelemetryProvider } from '@igniter-js/adapter-opentelemetry';

const telemetry = createOpenTelemetryProvider({
  serviceName: 'igniter-api',
  serviceVersion: '1.0.0',
  tracing: {
    enabled: true,
    exporter: 'jaeger',
    endpoint: 'http://localhost:14268/api/traces'
  },
  metrics: {
    enabled: true,
    exporter: 'prometheus',
    port: 9464
  }
});

const igniter = Igniter
  .context<AppContext>()
  .telemetry(telemetry)
  .create();
```

#### Automatic Instrumentation

Telemetry automatically traces:
- ✅ HTTP requests and responses
- ✅ Action execution times
- ✅ Procedure (middleware) execution
- ✅ Database queries (if using supported ORMs)
- ✅ External API calls

#### Manual Spans

```typescript
const userController = igniter.controller({
  actions: {
    create: igniter.mutation({
      handler: async ({ request, response }) => {
        // Create custom span for specific operation
        const span = igniter.telemetry.startSpan('validate-user-data');
        
        try {
          await validateUserData(request.body);
          span.end();
        } catch (error) {
          span.recordException(error);
          span.end();
          throw error;
        }
        
        const user = await db.users.create(request.body);
        return response.created({ user });
      }
    })
  }
});
```

---

### `.plugins(pluginsRecord)`

Registers **plugins** to extend functionality with reusable, self-contained modules.

```typescript
import { createAuditPlugin } from './plugins/audit';
import { createAuthPlugin } from './plugins/auth';
import { createEmailPlugin } from './plugins/email';

const igniter = Igniter
  .context<AppContext>()
  .plugins({
    audit: createAuditPlugin(),
    auth: createAuthPlugin(),
    email: createEmailPlugin()
  })
  .create();
```

#### Using Plugins in Actions

```typescript
const userController = igniter.controller({
  actions: {
    create: igniter.mutation({
      handler: async ({ request, context, plugins, response }) => {
        // ✅ Full type safety for plugin actions
        const isValid = await plugins.auth.actions.validateToken({
          token: request.headers.get('authorization')
        });
        
        if (!isValid) {
          return response.unauthorized({ message: 'Invalid token' });
        }
        
        const user = await context.db.users.create(request.body);
        
        // ✅ Log to audit trail
        await plugins.audit.actions.create({
          action: 'user:created',
          userId: user.id,
          metadata: { email: user.email }
        });
        
        // ✅ Send welcome email
        await plugins.email.actions.sendWelcome({
          to: user.email,
          name: user.name
        });
        
        return response.created({ user });
      }
    })
  }
});
```

<Callout type="success" title="Plugin Type Safety">
  All plugin actions are fully typed! IntelliSense shows available actions, required parameters, and return types.
</Callout>

---

### `.docs(config)`

Configures **API documentation** and interactive playground using OpenAPI specification.

```typescript
const igniter = Igniter
  .context<AppContext>()
  .docs({
    openapi: '3.1.0',
    info: {
      title: 'My API',
      version: '1.0.0',
      description: 'A fully type-safe API built with Igniter.js'
    },
    servers: [
      { url: 'https://api.example.com', description: 'Production' },
      { url: 'http://localhost:3000', description: 'Development' }
    ],
    playground: {
      enabled: true,
      route: '/docs',
      security: async (req) => {
        // Protect playground in production
        return req.headers.get('x-admin-key') === process.env.ADMIN_KEY;
      }
    }
  })
  .create();
```

#### Documentation Options

<TypeTable type={{
  openapi: {
    type: 'string',
    description: 'OpenAPI version (e.g., "3.1.0")',
    required: true
  },
  info: {
    type: 'OpenApiInfoObject',
    description: 'API metadata (title, version, description, contact, license)',
    required: false
  },
  servers: {
    type: 'OpenApiServerObject[]',
    description: 'Array of server configurations',
    required: false
  },
  securitySchemes: {
    type: 'Record<string, OpenApiSecuritySchemeObject>',
    description: 'Authentication schemes (API key, OAuth2, etc.)',
    required: false
  },
  playground: {
    type: 'object',
    description: 'Interactive API playground configuration',
    required: false
  }
}} />

---

### `.create()`

Finalizes the builder and returns the **fully configured Igniter instance** with all methods available.

```typescript
const igniter = Igniter
  .context<AppContext>()
  .config({ baseURL: 'https://api.example.com' })
  .store(redisStore)
  .jobs(jobsAdapter)
  .create(); // ← Returns configured instance

// Now you can use:
igniter.query(...)
igniter.mutation(...)
igniter.controller(...)
igniter.router(...)
igniter.procedure(...)

// And access adapters:
igniter.store
igniter.logger
igniter.jobs
igniter.telemetry
igniter.realtime
igniter.plugins
```

<Callout type="warn" title="Must Call .create()">
  You **must call `.create()`** to finalize the builder. Without it, you won't have access to `query`, `mutation`, `controller`, and other methods.
</Callout>

---

## Complete Examples

### Minimal Setup

Perfect for getting started or simple APIs:

```typescript
import { Igniter } from '@igniter-js/core';

interface AppContext {
  db: Database;
}

const igniter = Igniter
  .context<AppContext>()
  .create();

// Ready to create actions!
```

### Production Setup

Full-featured configuration for production applications:

```typescript
import { Igniter } from '@igniter-js/core';
import { createRedisStoreAdapter } from '@igniter-js/adapter-redis';
import { createBullMQAdapter } from '@igniter-js/adapter-bullmq';
import { createOpenTelemetryProvider } from '@igniter-js/adapter-opentelemetry';

// 1. Setup adapters
const redisStore = createRedisStoreAdapter({
  host: process.env.REDIS_HOST,
  port: Number(process.env.REDIS_PORT),
  password: process.env.REDIS_PASSWORD
});

const jobsAdapter = createBullMQAdapter({
  store: redisStore,
  defaultJobOptions: {
    removeOnComplete: 10,
    removeOnFail: 50,
    attempts: 3
  }
});

const telemetry = createOpenTelemetryProvider({
  serviceName: 'my-api',
  serviceVersion: '1.0.0'
});

// 2. Create jobs
const jobs = jobsAdapter.create({
  sendEmail: { handler: async (payload) => { /* ... */ } },
  processOrder: { handler: async (payload) => { /* ... */ } }
});

// 3. Configure Igniter
const igniter = Igniter
  .context(async (req: Request) => {
    const session = await getSession(req);
    return {
      db: database,
      user: session?.user || null,
      requestId: crypto.randomUUID()
    };
  })
  .config({
    baseURL: process.env.API_URL,
    basePATH: '/api/v1'
  })
  .store(redisStore)
  .jobs(jobs)
  .telemetry(telemetry)
  .docs({
    openapi: '3.1.0',
    info: {
      title: 'My Production API',
      version: '1.0.0'
    },
    playground: {
      enabled: process.env.NODE_ENV === 'development',
      route: '/docs'
    }
  })
  .create();

export { igniter };
```

### With Plugins

Extending functionality with modular plugins:

```typescript
import { Igniter } from '@igniter-js/core';
import { auditPlugin } from './plugins/audit';
import { authPlugin } from './plugins/auth';
import { emailPlugin } from './plugins/email';

const igniter = Igniter
  .context<AppContext>()
  .store(redisStore)
  .plugins({
    audit: auditPlugin,
    auth: authPlugin,
    email: emailPlugin
  })
  .create();

// Use plugins in actions
const userController = igniter.controller({
  actions: {
    create: igniter.mutation({
      handler: async ({ plugins, response }) => {
        await plugins.audit.actions.log({ event: 'user:create' });
        await plugins.email.actions.send({ to: 'admin@example.com' });
        return response.success({ message: 'Done' });
      }
    })
  }
});
```

---

## Type Inference

The builder progressively enhances types as you configure:

```typescript
// Step 1: No context yet
const step1 = Igniter;
// Type: IgniterBuilder<{}, {}, ...>

// Step 2: Context added
const step2 = Igniter.context<{ db: Database }>();
// Type: IgniterBuilder<{ db: Database }, {}, ...>

// Step 3: Store added
const step3 = step2.store(redisStore);
// Type: IgniterBuilder<{ db: Database }, {}, RedisStoreAdapter, ...>

// Step 4: Created
const step4 = step3.create();
// Now has: .query(), .mutation(), .controller(), etc.
// Plus: .store, .logger, .jobs, .telemetry, .realtime, .plugins
```

<Callout type="success" title="Full IntelliSense">
  At every step, TypeScript provides complete autocomplete and type checking. You can't make invalid configurations!
</Callout>

---

## Adapter Access

After calling `.create()`, all configured adapters are available directly on the Igniter instance:

```typescript
const igniter = Igniter
  .context<AppContext>()
  .store(redisStore)
  .jobs(jobsAdapter)
  .telemetry(telemetry)
  .create();

// Access adapters anywhere:
igniter.store.get('key');
igniter.store.set('key', 'value');
igniter.store.subscribe('channel', callback);

igniter.jobs.sendEmail.add({ to: 'user@example.com' });
igniter.jobs.processOrder.addBulk([{ orderId: '1' }, { orderId: '2' }]);

igniter.telemetry.startSpan('operation-name');

igniter.realtime.broadcast('channel', { data: 'value' });
```

---

## Best Practices

### 1. Single Igniter Instance

Create **one Igniter instance** per application and export it:

```typescript
// src/igniter.ts
export const igniter = Igniter
  .context<AppContext>()
  .config({ baseURL: process.env.API_URL })
  .create();
```

```typescript
// src/features/users/users.controller.ts
import { igniter } from '@/igniter';

export const userController = igniter.controller({ /* ... */ });
```

### 2. Environment-Based Configuration

Use environment variables for different environments:

```typescript
const igniter = Igniter
  .context<AppContext>()
  .config({
    baseURL: process.env.NODE_ENV === 'production' 
      ? 'https://api.example.com' 
      : 'http://localhost:3000',
    basePATH: '/api/v1'
  })
  .docs({
    playground: {
      enabled: process.env.NODE_ENV === 'development'
    }
  })
  .create();
```

### 3. Reusable Context Functions

Extract context logic into reusable functions:

```typescript
async function createRequestContext(req: Request): Promise<AppContext> {
  const session = await getSession(req);
  const user = session ? await db.users.findById(session.userId) : null;
  
  return {
    db,
    user,
    requestId: crypto.randomUUID(),
    ip: req.headers.get('x-forwarded-for') || 'unknown'
  };
}

const igniter = Igniter
  .context(createRequestContext)
  .create();
```

### 4. Conditional Adapters

Only add adapters when needed:

```typescript
let builder = Igniter.context<AppContext>();

// Only add telemetry in production
if (process.env.NODE_ENV === 'production') {
  builder = builder.telemetry(telemetryProvider);
}

// Only add jobs if Redis is available
if (process.env.REDIS_URL) {
  builder = builder.store(redisStore).jobs(jobsAdapter);
}

const igniter = builder.create();
```

---

## Next Steps

Now that you understand the Builder, learn how to create APIs:

<Cards>
  <Card title="Router" href="/docs/router">
    Learn how to create routers and assemble your API
  </Card>
  
  <Card title="Actions" href="/docs/actions">
    Create queries and mutations for your endpoints
  </Card>
  
  <Card title="Controllers" href="/docs/controllers">
    Organize related actions into logical groups
  </Card>
  
  <Card title="Procedures" href="/docs/procedures">
    Add reusable middleware to your actions
  </Card>
</Cards>
