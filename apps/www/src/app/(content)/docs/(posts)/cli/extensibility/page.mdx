# CLI Extensibility

The Igniter.js CLI is designed to be extensible and customizable. This guide explains the architecture and how you can extend it for your specific needs.

## Architecture Overview

The CLI is built with a modular architecture that separates concerns:

```
packages/cli/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts                    # Entry point and command definitions
â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”œâ”€â”€ build/                  # Schema generation and introspection
â”‚   â”‚   â”œâ”€â”€ docs/                   # OpenAPI documentation generation
â”‚   â”‚   â”œâ”€â”€ framework/              # Framework detection and dev server
â”‚   â”‚   â”œâ”€â”€ logger.ts               # Logging utilities
â”‚   â”‚   â”œâ”€â”€ scaffold/               # Code generation
â”‚   â”‚   â”‚   â””â”€â”€ providers/          # Schema providers (Prisma, Drizzle)
â”‚   â”‚   â””â”€â”€ setup/                  # Project initialization
â”‚   â”œâ”€â”€ lib/                        # Shared utilities
â”‚   â”‚   â”œâ”€â”€ spinner.ts              # Loading indicators
â”‚   â”‚   â”œâ”€â”€ template-helper.ts      # Handlebars template engine
â”‚   â”‚   â”œâ”€â”€ timeline-manager.ts     # Progress tracking
â”‚   â”‚   â””â”€â”€ port-manager.ts         # Port utilities
â”‚   â””â”€â”€ types/                      # TypeScript types
â””â”€â”€ templates/                      # Handlebars templates
    â””â”€â”€ feature/                    # Feature generation templates
```

## Template System

The CLI uses Handlebars for all code generation, making it easy to customize the generated code.

### Template Location

Templates are stored in `packages/cli/templates/` and are organized by type:

```
templates/
â””â”€â”€ feature/
    â”œâ”€â”€ controller.crud.hbs         # CRUD controller
    â”œâ”€â”€ controller.empty.hbs        # Empty controller
    â”œâ”€â”€ procedure.crud.hbs          # CRUD procedure
    â”œâ”€â”€ interfaces.crud.hbs         # Zod schemas
    â”œâ”€â”€ interfaces.empty.hbs        # Empty interfaces
    â”œâ”€â”€ index.crud.hbs              # CRUD index exports
    â””â”€â”€ index.empty.hbs             # Empty index exports
```

### Customizing Templates

You can modify templates to match your coding standards:

**Example**: Adding a custom header to controllers

Edit `templates/feature/controller.crud.hbs`:

```handlebars
/**
 * Generated by Igniter.js CLI
 * Controller: {{modelNamePascal}}
 * Date: {{currentDate}}
 */

import { igniter } from '@/igniter';
import { z } from 'zod';
// ... rest of template
```

### Using Templates

Templates are rendered via the `template-helper` module:

```typescript
import { renderTemplate } from '../lib/template-helper'

const content = await renderTemplate('controller.crud.hbs', {
  modelNameCamel: 'user',
  modelNamePascal: 'User',
  featureName: 'users'
})
```

### Available Helpers

Handlebars helpers are registered in `template-helper.ts`:

- `toPascalCase` - Converts to PascalCase
- `toCamelCase` - Converts to camelCase

**Example**:
```handlebars
{{toPascalCase featureName}}Controller
```

## Adding a New Schema Provider

You can add support for additional ORMs by implementing the `SchemaProvider` interface.

### 1. Define the Provider

Create a new file in `src/adapters/scaffold/providers/`:

```typescript
// src/adapters/scaffold/providers/typeorm.ts
import { ModelSchema, SchemaProvider, SchemaProviderField } from './base'

export class TypeORMProvider implements SchemaProvider {
  async getModel(modelName: string): Promise<ModelSchema | null> {
    // Implementation
  }

  async listModels(): Promise<string[]> {
    // Implementation
  }
}
```

### 2. Register the Provider

Update `src/adapters/scaffold.ts`:

```typescript
import { TypeORMProvider } from './scaffold/providers/typeorm'

function getSchemaProvider(providerName: string): SchemaProvider {
  if (providerName.toLowerCase() === 'prisma') {
    return new PrismaProvider();
  }
  if (providerName.toLowerCase() === 'drizzle') {
    return new DrizzleProvider();
  }
  if (providerName.toLowerCase() === 'typeorm') {
    return new TypeORMProvider();
  }
  throw new Error(`Unsupported schema provider: ${providerName}`);
}
```

### 3. Update Interactive Prompts

Add your provider to the feature generation wizard in `scaffold.ts`:

```typescript
const useModelChoice = await clack.select({
  message: 'Would you like to generate CRUD operations from a schema model?',
  options: [
    { value: 'none', label: 'No, create an empty feature' },
    { value: 'prisma', label: 'Yes, from a Prisma model' },
    { value: 'drizzle', label: 'Yes, from a Drizzle table' },
    { value: 'typeorm', label: 'Yes, from a TypeORM entity' },
  ]
})
```

## Adding New Features to Init

The `init` command is feature-based, making it easy to add new integrations.

### 1. Define the Feature

Add your feature to `src/adapters/setup/features.ts`:

```typescript
export const IGNITER_FEATURES: Record<string, FeatureDefinition> = {
  // ... existing features

  cache: {
    key: 'cache',
    name: 'Cache Layer',
    description: 'In-memory caching with Redis',
    dependencies: [
      { name: '@igniter-js/adapter-redis', version: 'latest' },
      { name: 'ioredis', version: '^5.6.1' }
    ],
    devDependencies: [
      { name: '@types/ioredis', version: '^4.28.10' }
    ],
    dockerServices: [{
      name: 'redis',
      image: 'redis:7-alpine',
      ports: ['6379:6379'],
      volumes: ['redis_data:/data']
    }],
    envVars: [
      { key: 'REDIS_URL', value: 'redis://localhost:6379' }
    ]
  }
}
```

### 2. Update TypeScript Types

Add your feature to `src/adapters/setup/types.ts`:

```typescript
export interface IgniterFeatures {
  store: boolean
  jobs: boolean
  mcp: boolean
  logging: boolean
  telemetry: boolean
  cache: boolean  // New feature
}
```

### 3. Update Prompts

The feature will automatically appear in the interactive setup wizard.

## Custom Commands

You can add new CLI commands by extending `src/index.ts`.

### Example: Adding a `test` Command

```typescript
// src/index.ts

program
  .command('test')
  .description('Run tests for the project')
  .option('--watch', 'Run tests in watch mode')
  .option('--coverage', 'Generate coverage report')
  .action(async (options) => {
    const testLogger = createChildLogger({ component: 'test-command' })
    
    try {
      const args = ['test']
      if (options.watch) args.push('--watch')
      if (options.coverage) args.push('--coverage')

      const { execa } = await import('execa')
      await execa('npm', args, { stdio: 'inherit' })
      
    } catch (error) {
      testLogger.error('Test command failed', { error })
      process.exit(1)
    }
  })
```

## Framework Support

The CLI auto-detects frameworks. You can add support for new frameworks.

### 1. Add Framework Detection

Update `src/adapters/framework/framework-detector.ts`:

```typescript
export type SupportedFramework = 
  | 'nextjs'
  | 'express'
  | 'fastify'   // New framework
  // ... other frameworks

export function detectFramework(): SupportedFramework {
  // Check for Fastify
  if (hasDependency('fastify')) {
    return 'fastify'
  }
  
  // ... existing detection logic
  
  return 'generic'
}
```

### 2. Add Dev Command

Update the dev command in `src/index.ts`:

```typescript
const frameworkCommands = {
  nextjs: "npm run dev",
  express: "npm run dev",
  fastify: "npm run dev",  // New framework
  // ... other frameworks
}
```

## Logger Customization

The CLI uses a structured logger. You can customize log levels and output.

### Example: Adding Custom Log Levels

```typescript
// src/adapters/logger.ts

export const logger = {
  // ... existing methods
  
  trace: (message: string, meta?: Record<string, any>) => {
    if (debugMode) {
      console.log(chalk.gray(`[TRACE] ${message}`), meta || '')
    }
  },
  
  metric: (message: string, value: number) => {
    console.log(chalk.cyan(`ðŸ“Š ${message}: ${value}`))
  }
}
```

## Configuration File Support

While the CLI currently uses command-line options, you can add configuration file support.

### Example Implementation

```typescript
// src/lib/config.ts
import { loadConfig } from 'c12'

export interface IgniterCLIConfig {
  framework?: string
  output?: string
  features?: string[]
}

export async function loadCLIConfig(): Promise<IgniterCLIConfig> {
  const { config } = await loadConfig<IgniterCLIConfig>({
    name: 'igniter',
    configFile: 'igniter.config',
    defaults: {
      output: 'src/',
      features: []
    }
  })
  
  return config
}
```

Then use it in commands:

```typescript
const config = await loadCLIConfig()
const outputDir = options.output || config.output
```

## Plugin System (Future)

While not currently implemented, here's a suggested approach for a plugin system:

### Plugin Interface

```typescript
export interface IgniterCLIPlugin {
  name: string
  version: string
  commands?: Command[]
  templates?: Record<string, string>
  providers?: SchemaProvider[]
}

export function registerPlugin(plugin: IgniterCLIPlugin) {
  // Register commands
  plugin.commands?.forEach(cmd => program.addCommand(cmd))
  
  // Register templates
  // Register providers
}
```

### Usage

```typescript
// igniter.plugin.ts
import { definePlugin } from '@igniter-js/cli'

export default definePlugin({
  name: 'my-plugin',
  version: '1.0.0',
  commands: [
    // Custom commands
  ],
  templates: {
    // Custom templates
  }
})
```

## Best Practices for Extension

### 1. Follow Existing Patterns

- Use `createChildLogger` for logging
- Use `@clack/prompts` for user input
- Follow the adapter pattern for integrations

### 2. Type Safety

Always provide TypeScript types for your extensions:

```typescript
export interface MyCustomOptions {
  feature: string
  provider: 'prisma' | 'drizzle'
}
```

### 3. Error Handling

Use structured error handling:

```typescript
try {
  // Your logic
} catch (error) {
  logger.error('Operation failed', { 
    error: error instanceof Error ? error : String(error) 
  })
  process.exit(1)
}
```

### 4. Testing

Create tests for your extensions:

```typescript
import { describe, it, expect } from 'vitest'
import { MyProvider } from './my-provider'

describe('MyProvider', () => {
  it('should list models', async () => {
    const provider = new MyProvider()
    const models = await provider.listModels()
    expect(models).toBeInstanceOf(Array)
  })
})
```

## Contributing

If you've created a useful extension, consider contributing it back to the project:

1. Fork the repository
2. Create a feature branch
3. Implement your extension
4. Add tests and documentation
5. Submit a pull request

## Next Steps

- Explore the [CLI source code](https://github.com/felipebarcelospro/igniter-js/tree/main/packages/cli)
- Read about [feature generation](/docs/cli/feature-generation)
- Learn about [core concepts](/docs/core-concepts)
